Java并发编程实战 

1.2 线程的优势
1. 有效的降低程序的开发和维护成本, 提升复杂应用程序的性能
2. 发挥多处理器强大的能力
3. 建模的简单性
4. 异步事件的简化处理
5. 响应更灵敏的用户界面

1.3 线程的风险

1.3.1 安全性问题

@NotThreadSafe
public class UnsafeSequence{
	private int value;

	//返回一个唯一的数值
	public int getNext(){
		return value++;
	}
}

如果执行时机不对, 那么两个线程在调用getNext()时会得到相同的值

@NotThreadSafe 标明不支持并发
@ThreadSafe 标明支持并发
@Immutable 标明不可被修改

使用synchronized同步方法 

@ThreadSafe
public class UnsafeSequence{
	@GuardedBy("this") private int value;

	//返回一个唯一的数值
	public synchronzied int getNext(){
		return value++;
	}
}


1.3.2 活跃性问题
当某个操作无法执行下去时, 就会发生活跃性问题, 在串行程序中, 活跃性问题的形式之一就是无意中造成的无限循环, 
从而使循环之后的代码无法得到执行

包括 死锁, 饥饿, 活锁

1.3.3 性能问题
响应不灵敏, 吞吐率过低, 资源消耗过高, 可伸缩性较低. 

框架通过在框架线程中调用应用程序代码将并发性引入到程序中, 在代码中将不可避免地访问应用程序状态, 因此所有访问
这些状态的代码都必须是线程安全的

下面的模块都将在应用程序之外的线程中调用应用程序的代码:
Timer: 确保TimerTask 访问的对象本身是线程安全的, 从而就能把线程安全性封装在共享对象内部. 
Servlet 和 JavaServer Page(JSP): Servlet和 JSP 以及在ServletContext和HttpSession 等容器中保存的Servlet
过滤器和对象, 都必须是线程安全的.
RMI: 远程对象必须注意两个线程的安全性问题, 正确的协同在多个对象中共享的状态, 以及对远程对象本身状态的访问. 
与Servlet相同, RMI对象应该做好被多个线程同时调用的准备，并且必须确保他们自身的线程安全性

第二章

线程安全性 

当多个线程访问某一个变量, 并且有一个线程执行写入操作时, 必须采用同步机制来协同这些线程对变量的访问. 

如果当多个线程访问同一可变状态变量时候, 没有使用合适的同步, 那么程序就会出现错误, 三种方式修复这个问题:
不在程线程间共享变量
将状态变量修改为不可变变量
在访问状态变量时同步

线程安全的定义: 
当多个线程访问某个类时, 不管运行环境采用何种调度方式或者这些线程将如何交替执行, 并且在主调代码中不需要
任何额外的同步或协同, 这个类都能表现出正确的行为, 那么就称这个类为线程安全的 

在线程安全类中封装了必要的同步机制, 因此客户端无须进一步采取同步措施

@ThreadSafe 
public class StatelessFactorizer implements Servlet{
	public void service(ServletRequest req, ServletResponse resp){
		BigInteger i = extractFromRequest(req);
		BigInteger[] factors = factor(i);
		encodeIntoResponse(resp, factors);
	}
}

无状态的对象一定是线程安全的

大多数的Servlet都是无状态的, 从而极大地降低了在实现Servlet线程安全性时的复杂性, 只有当Servlet在处理请求时需要保存一些信息
线程安全性才会成为一个问题

竞态条件Race condition
当某个计算的正确性取决于多个线程交替的执行时序时候, 那么就会发生竞态条件

先检查后执行 check-then-act操作就会产生一种竞态

@NotThreadSafe
public class LazyInitRace{
	private ExpensiveObject instance = null;

	public ExpensiveObject getInstance(){
		if(instance == null){
			instance = new ExpensiveObject();
		}
		return instance;
	}
}

复合操作

假定有两个操作A和B, 如果从执行A的线程来看, 当另一个线程执行B时, 要么将B全部执行完, 要么完全不执行B, 那么A和B对彼此来说是原子的,
原子操作是指, 对于访问同一个状态的所有操作, 包括该操作本身来说, 这个操作是一个以原子方式执行的操作.

使用AtomicLong类型的变量来统计已处理的请求的数量

@ThreadSafe
public class CountingFactorizer implements Servlet{
	private final AtomicLong count = new AtomicLong(0);

	public long getCount{rerturn count.get();}

	public void service(ServletRequest req, ServletResponse resp){
		BigInteger i = extractFromRequest(req);
		BigInteger[] factors = factor(i);
		count.incrementAndGet();
		encodeIntoResponse(resp, factors);
	}
}

尽可能使用现有安全对象来管理类的状态, 与非线程安全的对象相比, 判断线程安全对象的可能状态及其状态转换情况要更为容易,
从而也更容易维护和验证线程安全性

要保持状态的一致性, 就需要在单个原子操作中更新所有相关的状态变量

内置锁

Java提供了一种内置锁机制来支持原子性, 同步代码块synchronized block

一个作为锁的对象引用, 一个作为由这个锁保护的代码块

synchrozied(lock){
	...
}

重入 

内置锁是可以重入的, 因此如果某个线程试图获得一个已经由它自己持有的锁, 那么这个请求就会成功

对于可能被多个线程同时访问的可变状态变量, 在访问它时都需要持有同一个锁, 在这种情况下, 我们称状态变量是由这个锁保护的

对于每个包含变量的不变性条件, 其中涉及的所有变量都要由同一个锁来保护

在执行时间较长的计算或者可能无法快速完成的操作时, 例如网络i/o, 一定不要持有锁

第三章 对象的共享

重排序: reordering  在没有同步的情况下, 编译器, 处理器以及运行时都可能对操作的执行顺序进行一些意想不到的调整.

加锁的含义不仅仅局限于互斥行为, 还包括内存可见性, 为了确保所有线程都能看到共享变量的最新值, 所有执行读操作或者写操作的线程
都必须在同一个锁上同步

volatile

把变量声明为volatile类型后, 会注意到这个变量是共享的, 因此不会将该变量上的操作与其他内存操作一起重排序

一种比sychronized更轻量的同步锁

仅当volatile变量能简化代码的实现以及对同步策略的验证时, 才应该使用它们. 如果在验证正确性时需要对可见性进行复杂的判断， 
那么就不要使用volatile变量. volatile变量的正确使用方式包括: 确保它们自身状态的可见性, 确保它们所引用对象的状态可见性,
以及标识一些重要程序生命周期事件的发生

加锁机制既可以确保可见性又可以确保原子性, 而volatile变量只能确保可见性

满足以下条件时候才能使用volatile变量
1. 对变量的写入操作不依赖变量的当前值, 或者只有单个线程更新变量的值
2. 该变量不会与其他状态变量一起加入不变性条件中
3. 访问变量不需要加锁

发布与逸出
发布 public: 使对象能够在当前作用域之外的代码中使用
逸出 escape: 当某个不该被发布的对象被发布时, 这种情况被称之为逸出

不要在构造过程中使this引用逸出

在构造过程中使this引用逸出的一个常见错误是, 在构造函数中启动一个线程. 当对象在其构造函数中创建一个线程时, this引用都会被
新创建的线程共享

使用工厂方法来防止this引用在构造过程中逸出

public class SafeListener{
	private final EventListener listener;
	private SafeListener(){
		listener = new EventListener(){
			public void onEvent(Event e){
				doSomething(e);
			}
		}
	}

	public static SafeListener newInstance(EventSource source){
		SafeListener safe = new SafeListener();
		source.registerListener(safe.listener);
		return safe;
	}
}

Ad-hoc线程封闭

维护线程封闭性的职责完全由程序实现来承担. 
Ad-hoc线程封闭性是非常脆弱的, 因为没有任何一种语言特性, 能将对象封闭到目标线程上

栈封闭
只能通过局部变量才能访问对象, 比ad-hoc更易于维护, 也更加健壮
基本类型的局部变量, 无论如何不会破坏栈封闭性

基本类型的局部变量与引用变量的线程封闭性
public int loadTheArk(Collection<Animal> candidates){
	SortedSet<Animal> animals;
	int numPairs = 0;
	Animal candiate = null;

	animals = new TreeSet<Animal>(new SpeciesGenderComparator());
	animals.addAll(candidates);
	for(Animal a: animals){
		if(candidate == null || !candidate.isPotentialMate(a)){
			candidate = a;
		}else{
			ark.load(new AnimalPair(candidate, a));
			++numPairs;
			candidate = null;
		}
	}
	return numPairs;
}

维持线程封闭性的更规范方法

使用ThreadLocal

ThreadLocal提供了get/set等访问接口或者方法, 这些方法为每个使用该变量的线程都存有一份独立的副本, 因此get总是返回由当前线程
在调用set时设置的最新值

ThreadLocal变量通常用于防止对可变单实例变量Singleton或全局变量进行共享

eg: 单线程应用程序中可能会维持一个全局的数据库连接, 并在程序启动时初始化这个连接对象不一定是线程安全的, 因此, 当多线程应用程序
在没有协同的情况下使用全局变量时, 就不是线程安全的.通过将JDBC的连接保存在ThreadLocal中, 每个线程都会拥有属于自己的连接

使用ThreadLocal来维护线程封闭性

private static ThreadLocal<Connection> connectionHolder = new ThreadLocal<>(){
	public Connection initialValue(){
		return DriverManager.getConnection(DB_URL);
	}
}

public static Connection getConnection(){
	return connectionHold.get();
}

当某个频繁执行的操作需要一个临时对象, 比如一个缓冲区, 同时又希望避免在每次执行时都重新分配该临时对象, 就可以使用这项技术
当某个线程初次调用ThreadLocal.get方法时, 就会调用initialValue()来获得初始值，这些特定于线程的值保存在Thread对象中, 当
线程终止后, 这些值会作为垃圾回收

假如你需要将一个单线程程序移至多线程环境中, 通过将共享的全局变量转换为ThreadLocal对象，可以维持线程安全性

不可变对象一定是线程安全的

即使所有的域都是final类型的, 这个对象仍然是可变的, 因为在final类型的域可以保存对可变对象的引用

当满足以下条件时, 对象才是不可变的
*对象创建以后其状态就不能修改
*对象所有的域都是final类型
*对象是正确创建的(this引用没有逸出)


除非需要更高的可见度, 否则应将所有的域都声明为private, 除非需要某个域是可变的, 否则应将其声明为final域

每当需要对一组相关数据进行原子方式执行某个操作时, 就可以考虑创建一个不可变的类来包含这些数据

使用Volatile类型来发布不可变对象

@Immutable
class OneValueCache{
	private final BigInteger lastNumber;
	private final BigInteger[] lastFactors;

	public OneValueCache(BigInteger i, BigInteger[] factors){
		lastNumber = i;
		lastFactors = Arrays.copyOf(factors, factors.length);
	}

	public BigInteger[] getFactors(BigInteger i){
		if(lastNumber == null || !lastNumber.equals(i)) return null;
		else return Arrays.copyOf(lastFactors, lastFactors.length);
	}
}

对于在访问和更新多个相关变量时出现的竞争条件问题, 可以通过将这些变量全部保持在一个不可变对象中来消除

@ThreadSafe
public class VolatileCachedFactorizer implements Servlet{
	private volatile OneValueCache cache = new OneValueCache(null, null);

	public void service(ServletRequest req, ServletResponse resp){
		BigInteger i = extractFromRequest(req);
		BigInteger[] factors = cache.getFactors(i);
		if(factors == null){
			factors = factor(i);
			cache = new OneValueCache(i, factors);
		}
		encodeIntoResponse(resp, factors);
	}
}

与cache相关的操作不会相互干扰, 因为OneValueCache是不可变的, 并且在每条相应的代码中路径中只会访问它一次.
通过使用包含多个状态变量的容器来维持不变性条件, 并使用一个volatile类型的引用来确保可见性, 使得Volatile 
Cached Factorizer 在没有显示的使用锁的情况下仍然是线程安全的

安全发布

某些情况下, 我们希望在多个线程间共享对象, 此时必须确保安全的进行共享, 如果只是将对象保存在公有域中, 那么还不足
安全的发布这个对象

//不安全的发布

public Holder holder;

public void initialize(){
	holder = new Holder(42);
}

//不正确的发布

你不能之外一个尚未完全创建的对象拥有完整性, 某个观察该对象的线程将看到对象处于不一致的状态, 然后看到对象的状态
突然发生变化, 即使线程在对象发布后还没有修改过它

不安全的发布, 那么另一个线程在调用时可能抛出AssertionError

//不太好的做法
public class Holder{
	private int n;
	public Holder(int n){
		this.n = n;
	}
	public void assertSanity(){
		if(n != n){
			throw new AssertionError("This statement is false");
		}
	}
}


安全发布常用模式

要安全的发布一个对象, 对象的引用以及对象的状态必须同时对其他线程可见, 一个正确构造对象可以通过以下方式来安全的发布
*在静态初始化函数中初始化一个对象的引用
*将对象的引用保存在volatile类型的域或者AtomicReference中
*将对象的引用保存在某个正确构造对象的final类型域中
*将对象的引用保存在一个由锁包含的域中

线程安全库中的容器类提供了以下安全发布的保证: 
*通过将一个键值放入Hashtable, synchronizedMap, 或者concurrentMap中, 可以安全地将它发布给任何从这些容器访问它的线程
*通过将元素放入Vector, CopyOnWriteArrayList, CopyOnWriteArraySet, synchronziedList或者synchronziedSet中
可以将该元素安全的发布到任何这些容器中访问该元素的线程
*通过将某个元素放入BlockQueue或者ConcurrentListedQueue中, 可以将元素安全地发布到任何从这些队列中访问该元素的线程
类库中其他数据传递机制 Future 和 Exchanger 同样能实现安全发布

静态初始化器由JVM在类的初始化阶段执行, 由于JVM内部存在着同步机制, 因此通过这种方式初始化任何对象都可以被安全的发布
public static Holder holder = new Holder(42);

事实不可变对象

如果对象从技术上看是可变的, 但其状态在发布后不会再改变, 那么把这种对象称为事实不可变对象(Effectively Immutable Object)

在没有额外同步的情况下, 任何线程都可以安全的使用被安全发布的事实不可变对象


例如: Date本身是可变的, 但是如果作为不可变对象来使用, 那么在多个线程共享Date对象时, 就可以省去对锁的使用
假设需要维护一个Map对象, 其中保存了每位用户的最近登录时间:

public Map<String, Date> lastLogin = Collections.synchronizedMap<new HashMap<String, Date>());
如果Date对象的值在被放入Map后就不会改变, 那么synchronizedMap中的同步机制就足以使Date值被安全发布, 并且访问时不需要额外同步

可变对象

如果对象在构造后可以修改, 那么安全发布只能确保当时状态的可见性, 对于可变对象, 不仅在发布时需要同步, 而且在每次对象访问时需要
使用同步来确保后续修改操作的可见性.要安全的共享可变对象, 这些对象就必须被安全发布, 并且必须是线程安全的或者由某个锁保护起来

对象的发布取决于它的可变性: 
*不可变对象可以通过任意机制来发布
*事实不可变对象必须通过安全方式来发布
*可变对象必须通过安全方式来发布, 并且必须是线程安全的或者某个锁保护起来

安全的共享对象

并发程序中使用和共享对象时, 可以使用一些实用的策略, 包括:
线程封闭: 线程封闭的对象只能由一个线程拥有, 对象被封闭在该线程中, 并且只能由这个线程修改
只读共享: 在没有额外同步的情况下, 共享的只读对象可以由多个线程并发访问, 但任何线程都不能修改它, 共享的只读对象包括不可变对象
和事实不可变对象
线程安全共享: 线程安全的对象在其内部实现同步, 因此多个线程可以通过对象的公有接口来进行访问而不需要进一步的同步
保护对象: 被保护的对象只能通过持有特定的锁来访问. 保护对象包括封装在其他线程安全对象中的对象, 以及已发布的并且由某个特定锁保护的对象

第四章
对象的组合

4.1 设计线程安全的类

三个基本要素:
1. 找出构成对象状态的所有变量
2. 找出约束状态变量的不变性条件
3. 建立对象状态的并发访问管理策略

同步策略(Synchronization policy)定义了如何在不违背对象不变条件或后验条件的情况下对其状态的访问操作进行协同

如果不了解对象的不变性条件与后验条件, 那么就不能确保线程安全性, 要满足在状态变量的有效值或状态转换上的各种约束条件
, 就需要借助原子性和封装性

4.2实例封闭

如果对象不是线程安全的, 就需要确保该对象只能由单个线程访问或者通过一个锁来保护该对象的所有访问

将数据封装在对象内部, 可以将数据的访问限制在对象的方法上, 从而更容易确保线程在访问数据时总能持有正确的锁

PersonSet说明了如何通过封闭与加锁等机制使一个类成为线程安全的

通过封闭机制来确保线程安全
@ThreadSafe
public class PersonSet{
	@guardedBy("this")
	private final Set<Person> mySet = new HashSet<>();               <------ private final 限制了mySet不会逸出

	public synchronized void addPerson(Person p){					 <------ 状态由内置锁保护
		mySet.add(p);
	}

	public synchronized boolean containsPerson(Person p){			 <------ 状态由内置锁保护
		return mySet.contains(p);
	}
}


封闭机制更易于构造线程安全的类, 因为当封闭类的状态时, 在分析类的线程安全性时就无需检查整个程序

4.2.1 Java监视器模式

通过一个私有锁来保护状态

public class privateLock{
	private final Object myLock = new Object();
	@GuardedBy("mylock") Widget widget;

	void someMethod(){
		synchronized(mylock){
			//访问或修改widget状态
		}
	}
}

使用私有的锁对象而不是对象的内置锁, 有许多优点, 私有的锁对象可以将锁封装起来, 使客户代码无法得到锁, 但客户代码可以通过
公有方法来访问锁, 以便参与到它的同步策略中.

eg: 

每台车都有一个String对象来标识, 并且拥有一个相应的位置坐标(x, y)

Map<String, Point> locations = vehicles.getLocations();
for(String key: locations.keySet()){
	renderVehicle(key, locations.get(key));
}

执行更新操作的线程通过从GPS设备上获得的数据或者调度员从GUI界面上输入的数据来修改车辆位置
void vehicleMoved(VehicleMovedEvent evt){
	Point loc = evt.getNewLocation();
	vehicles.setLocation(evt.getVehicledId(), loc.x, loc.y);
}

Java监视器模式实现的车辆追踪

@ThreadSafe
public class MonitorVehicletracker{
	@GuardedBy("this")
	private final Map<String, MutablePoint> locations; 

	public MonitorVehicleTracker(Map<String, MutablePoint> locations){
		this.locations = deepCopy(locations);
	}

	public synchronized Map<String, MutablePoint> getLocations(){
		return deepCopy(locations);                    <---- locations 是可变的hashMap, 需要复制确保线程安全
	}

	public synchronized MutablePoint getLocation(String id){
		MutablePoint loc = locations.get(id);
		return loc == null ? null : new MutablePoint(loc);
	}

	public synchronized void setLocation(String id, int x, int y){
		MutablePoint loc = locations.get(id);
		if(loc == null){
			throw new IllegalArgumentException("No such ID: "+ id);
		}
		loc.x = x;
		loc.y = y;
	}

	private static Map<String, MutablePoint> deepCopy(Map<String, MutablePoint> m){
		Map<String, MutablePoint> result = new HashMap<String, MutablePoint>();
		for(String id: m.keySet()) 
			result.put(id, new MutablePoint(m.get(id)));  <----- 该类是可变类, 需要复制确保线程安全
		return Collections.unmodifiableMap(result);
	}

	public class MutablePoint{...}
}

eg: 基于委托的车辆追踪器
	构造一个委托给线程安全类的车辆追踪器

用不可变Point来代替MutablePoint以保存位置

@Immutable
public class Point{
	public final int x ,y;
	public Point(int x, int y){
		this.x=x;
		this.y=y;
	}
}


将线程安全委托给ConcurrentHashMap

@ThreadSafe
public class DelegatingVehicleTracker{
	private final ConcurrentMap<String, Point> locations;
	private final Map<String, Point> unmodifiableMap;

	public DelegatingVehicleTracker(Map<String, Point> points){
		locations = new ConcurrentHashMap<String, Point>(points);
		unmodifiableMap = Collections.unmodifiableMap(locations);
	}

	public Map<String, Point> getLocations(){
		return unmodifiableMap<>();
	}

	public Point getLocation(String id){
		return locations.get(id);
	}

	public void setLocation(String id, int x, int y){
		if(locations.replace(id, new Point(x, y)) == null){
			throw new IllegalArgumentException("Invalid vehicle name: "+ id);
		}
	}
}

返回locations的静态拷贝而非浅拷贝

public Map<String, Point> getLocations(){
	return Colllections.unmodifiableMap(new HashMap<String, Point>(locations));  
	<---- 由于Map内容是不可变的, 因此只需要复制map结构, 而不用复制它的内容
}


将线程安全委托给多个状态变量

public class VisualComponent{
	private final List<KeyListener> keyListeners = new CopyOnWriteArrayList<KeyListener>();
	private final List<MouseListener> mouseListeners = new CopyOnWriteArrayList<MouseListener>();

	public void addKeyListener(KeyListener listener){
		keyListener.add(listener);
	}

	public void addMouseListener(MouseListener listener){
		mouseListener.add(listener);
	}

	public void removeKeyListener(KeyListener listener){
		keyListeners.remove(listener);
	}

	public void removeMouseListener(MouseListener listener){
		mouseListeners.remove(listener);
	}
}

CopyOnWriteArray来保存各个监听器列表, 是一个线程安全的链表, 特别适用于管理监听器列表

先检查后执行的操作没有用加锁机制无法保证原子性

如果一个状态变量是线程安全的, 并且没有任何不变性条件来约束它的值, 在变量的操作上也不存在任何不允许的状态转换
, 那么就可以安全的发布这个变量

车辆追踪器的另一个版本, 并在这个版本中发布底层可变状态, 使用可变且线程安全的Point类

把x, y放到一个数组中, 避免分别提供get方法

线程安全且可变的Point类

@ThreadSafe
public class SafePoint{
	@GuardBy("this") private int x, y;

	private SafePoint(int[] a){
		this(a[0], a[1]);
	}

	private SafePoint(SafePoint p){
		this(p.get());
	}

	public SafePoint(int x, int y){
		this.x = x;
		this.y = y;
	}

	public synchronized int[] get(){
		return new int[] {x, y};
	}

	public synchronized void set(int x, int y){
		this.x = x; 
		this.y = y;
	}
}

@ThreadSafe 
public class PublishingVehicleTracker{
	private final Map<String, SafePoint> locations; 
	private final Map<String, SafePoint> unmodifiedMap;

	public PublishingVehicleTracker(Map<String, SafePoint> locations){
		this.locations = new ConcurrentHashMap<String, SafePoint>)(locations);
		this.unmodifiableMap = Collections.unmodifiableMap(this.locations);
	}

	public Map<String, SafePoint> getLocations(){
		return unmodifiableMap;
	}

	public SafePoint getLocation(String id){
		return locations.get(id);
	}

	public void setLocation(String id, int x, int y){
		if(!locations.containsKey(id)) 
			throw new Illegal
	}
}

PublishingVehicleTracker是线程安全的, 但如果它在车辆位置有效值上施加了任何约束, 那么就不再是线程安全的.
如果需要对车辆位置的变化进行任何判断或者当前位置变化时执行了一些操作, 那么则是线程不安全的

在现有的线程安全类中添加功能

1. 修改原始类, 但通常无法访问或修改类的代码
2. 扩展这个类并添加线程安全的方法

扩展Vector并增加一个"putIfAbsent"的方法

@ThreadSafe
public class BetterVector<E> extends Vector<E>{
	public synchronized boolean putIfAbsent(E x){
		boolean absent = !contains(x);
		if(absent)
			add(x);
		return absent;
	}
}

扩展方法比直接将代码添加到类中更加脆弱, 因为同步策略实现被分布到多个单独维护的源代码文件中, 如果底层类改变了
同步策略, 并选择了不同的锁来保护它的状态变量, 那么子类会被破坏, 因为同步策略改变后它无法再使用正确的锁来控制
对基类状态的并发访问.

4.4.1 客户端加锁机制

3. 扩展类的功能, 将扩展代码放入一个"辅助类"中

@NotThreadSafe
public class ListHelper<E>{
	public List<E> list = Collections.synchronizedList(new ArrayList<E>());
	...
	public synchronized boolean putIfAbsent(E x){
		boolean absent = !list.contains(x);
		if(absent)
			list.add(x);
		return absent;	
	} 
}

问题在于在错误的锁上进行了同步, 无论list使用哪一个锁来保护它的状态, 可以确定的是这个锁并不是ListHelper上的,
ListHelper只是带来了同步的假象, 这意味着ListHelper相对于List其他的操作来说并不是原子的

要让这个方法能正确执行, 必须使List实现客户端加锁或外部加锁时使用同一个锁。 

通过客户端加锁来实现"putIfAbsent"

@ThreadSafe
public class ListHelper<E>{
	public List<E> list = Collections.synchronizedList(new ArrayList<E>());
	...
	public boolean putIfAbsent(E x){
		synchronized(list){
			boolean absent = !list.contains(x);
			if(absent)
				list.add(x)
				
		}
	}
}