I 第一部分 Spring的核心


Spring采用以下4种关键策略降低Java开发的复杂性：
1. 基于POJO的轻量级和最小入侵性编程
2. 通过依赖注入和面向接口实现松耦合
3. 基于切面和惯例进行声明式编程
4. 通过切面和模版减少样板代码


装配Bean
1. 创建Spring配置
 Spring是一个基于容器的框架，我们需要配置Spring来告诉它需要加载哪些Bean和如何装配这些Bean
 两种配置Bean的方式
 1.XML文件
 2.Java注解

Bean在XML中的位置
在XML文件中声明Bean，Spring配置文件的根元素是来源于Spring Bean命名空间所定义的<bean>元素：
<beans xmlns=""
      xmlns:xsi=""
      xsi:schemaLocation="">
      <!-- bean declarations go here -->
</beans>

Java自带多种XML命名空间，通过这些命名空间可以配置Spring容器
aop 声明切面以及将@AspectJ注解的类代理为Spring切面提供配置元素
beans 支持声明Bean和装配Bean
context 为配置Spring 应用上下文提供了配置元素，包括自动检测和自动装配Bean,注入非Spring直接管理的对象
jee 为声明消息驱动的POJO提供了配置元素
lang 配置由Groovy, JRuby, BeanShell等脚本实现的Bean
mvc 启动Spring MVC的能力 例如面向注解的控制器, 视图控制器，和拦截器
oxm 支持Spring对象到XML的映射配置
tx 提供声明式事物配置
util 工具类元素

声明一个Bean

<bean id="duke
      class="om.spring.springidol.Juggler" />

      <bean> 元素是Spring中最基本的配置单元，通过该元素Spring将创建一个对象。id属性定义了Bean的名字，也作为Bean在Spring容器中的引用.

通过构造器注入

1. 使用默认的构造器
2. 带一个int参数的构造方法

XML声明方式
<bean id="duke"
      class="com.spring.springidol.Juggler">
      <constructor-arg value= "15"/>
</bean>

扩展成一个PoeticJuggler
<bean id="duke"
      class="com.spring.springidol.Juggler">
      <constructor-arg value= "15"/>
      <constructor-arg ref="sonnet29" />
</bean>
逻辑类似于
Poem sonnet29 = new sonnet29();
Performer duke = new PoeticJuggler(15, sonnet29);

通过工厂方式创建Bean
Spring 支持通过<bean>元素的factory-method属性来装配工厂创建的Bean
<bean id= "theStage"
      class = "com.spring.springidol.Stage"
      factory_method = "getInstance" />

Bean的作用域
所有的Bean默认都是单列

如何让容器分配Bean时，每次请求都产生一个新的实例？
只需要配置Bean的scope属性为prototype即可
<bean id="ticket"
      class="com.spring.springidol.Ticket" scope = "prototype"/>
其他的作用域选项
singleton 在每一个Spring容器中，一个Bean定义只有一个对象实例 默认
prototype 允许Bean被实例化任意次
request 在一次HTTP请求中，每个Bean定义对应一个实例 仅web有效
session 一个HTTP session中 每个Bean对应一个实例 仅web有效

Bean的初始化和销毁
使用 init-method和destroy method参数来配置<bean>元素
<bean id = "auditorium"
      class = "com.spring.springidol.Auditorium"
      init-method = "turnOnLights"
      destroy-method = "turnOffLights" />
另一种方案是实现InitializingBean和DisposableBean接口

注入Bean属性
简单的赋值 使用property标签
<bean id="kenny"
      class = "com.spring.springidol.Instrumentalist"
      <property name = "song" value = "Jingle Bells" />
</bean>

用其他Bean赋值 使用ref
<bean id="kenny2"
      class ="come.spring.springidol.Instrumentalist">
      <property name = "song" value ="Jingle Bells"
      <property name = "instrument" ref = "saxophone" />
</bean>
调用Bean
ApplicationContext ctx = new ClassPathXmlApplicationContext("com/spring/springidol/spring-idol.xml");
Performer performer = (Performer) ctx.getBean("kenny");
performer.perform();

注入内部Bean

<bean id="kenny"
      class = "com.spring.springidol.Instrumentalist">
      <property name = "song" value = "Jingle Bells" />
      <property name = "instrument">
        <bean class= "springinaction.springidol.Saxophone" />
      </property>
</bean>

装配集合

<list> 装配list类型的值
<set> 装配set类型的值 不允许重复
<map> 装配map类型的值 名称和值可以是任意类型
<props> 装配properties类型的值 名称和值都必须是String型

2.3 使用表达式装配
Spring Expression Language SpEL 一种强大简洁的装配方式

3.最小化Spring XML配置

自动装配 autowiring 减少<property> 元素和 <constructor-arg> 元素
自动检测 autodiscovery 更进一步自动识别哪些类需要配置为bean

4种类型的自动装配

byName 把与Bean属性具有相同名字(或id)的其他Bean自动装配到Bean对应的属性中
byType 把与Bean属性具有相同类型的其他Bean自动装配到该Bean的对应属性中
constructor 把与Bean的const 具体相同类型的其他Bean自动装配到Bean构造器对应args中
autodetect 首先尝试用const进行装配失败了尝试byType

3.2使用注解装配

Spring容器默认禁用注解装配 在使用基于注解的自动装配前 需要在Spring配置中启动它，
<context:annotation-config>

3种自动装配注解
1. @Autowired
2. @Inject
3. @Resource

1.@Autowired
可以对方法进行标注
@Autowired
public void setInstrcument(Instrument instrument){
	this.instrucment = instrucment
}
可以对构造器进行标注
@Autowired
public Instrumentalist(Instrument instrument){
	this.instrucment = instrucment
}
可以直接标注属性
@Autowired
private Instrument instrument;

可选的自动装配
1. 强契约，所标注的属性或者参数必须是可以装配的
2. Null 也可以接受 @Autowired(required = false)

多个Bean满足装配条件时，使用@Qualifier注解
@Autowired
@Qualifier("guitar")
private Instrument instrument;

还可以使用@Qualifier标注Guitar类
@Qualifier("stringed")
public class Guitar implements Instrument{
	...
}

创建自定义的限定器(Qualifier)

创建@Stringedinstrument注解来充当限定器

@Target({ElementType.FIELD, ElementType.PARAMETER, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Qualifier
public @interface StringInstrument{...}

可以用它来代替Qualifier

@StringedInstrument
public class Guitar implements Instrument{...}

2.@Inject
类似Autowired

3.注解中使用表达式
@Value("Eruption")
private String song;

@Value("#{SystemProperties.myFavoriteSong}")
private String song;

自动检测Bean
<context:component-scan> 允许Spring自动检测Bean和定义Bean

标注Bean
@Component 通用的构造型组件，标识为Spring组件
@Controller 标识为SpringMVC里的controller
@Repository 标识为数据仓库
@Service 标识该类为服务

过滤组件扫描
<context: include-filter> 的type和expression属性一起协作来定义组件扫描策略
过滤器类型
1.annotation 过滤器扫描使用指定注解所标注的类，通过expression属性指定要扫描的注解
2.assignable 过滤器扫描派生于expression属性所指定的类型的那些类
3.aspectj  过滤器扫描与expression属性所指定的AspectJ表达式所匹配的那些类
4.custom 自定义
5.regex 扫描正则表达式匹配的类

3.4 使用Spring基于Java的配置
在基于Java配置里使用@Configuration注解的Java类，就等价于XML配置中的<bean>元素

定义一个配置类
在基于Java的配置里使用@Configuration注解的Java类就等价于XML配置中的<beans>元素

@Configuration
public class SpringIdolConfig{
  //Bean declaration methods go here
}

@Configuration注解作为一个标识告知Spring：这个类包含一个或多个Spring Bean的定义，这些Bean定义是使用@Bean注解所标注的方法

声明一个简单的Bean
使用@Bean注解标注一个方法来定义duke Bean

@Bean
public Performer duke(){
  return new Juggler();
}

使用Spring基于Java的配置进行注入

使用Spring基于Java编写一个返回类实例的方法 直接传值
为Bean装配另一个Bean的引用

@Bean
public Performer poeticDuke(){
  return new PoeticJuggler(sonnet29());
}
不会让方法产生新的实例

4. 面向切面的Spring

通知（Advice)
5种类型
Before 在方法被调用之前调用通知
After 在方法完成后调用通知, 无论方法执行成功与否
After-returning 在方法成功执行之后调用通知
After-throwing 在方法抛出异常之后调用通知
Around 通知包裹了被通知的方法，在被通知的方法调用之前和调用之后 执行自定义的行为

连接点（JoinPoint)
连接点是在应用执行的过程中能够插入切面的一个点，这个点可以是调用方法，抛出异常，修改字段时，切面代码可以利用这些点插入到应用的正常流程之中，
并添加新的行为

切点（Pointcut)
切点的定义会匹配通知所要织入的一个或多个连接点，通常使用明确的类和方法名称来指定这些切点，或者是利用正则表达式定义匹配的类和方法名称

切面 （Aspect）
切面是通知和切点的结合

引入（Introduction）
引入允许我们向现有的类添加新的方法和属性

织入（Weaving）
织入是将切面应用到目标对象来创建新的代理对象的过程。切面在指定的连接点被织入到目标对象中，在目标对象的生命周期里有多个点可以进行织入。

编译期-切面在目标类编译时被织入,比如ApsectJ织入编译器

类加载器-切面在目标类加载到JVM时被织入

运行期-切面在应用运行的某个时刻被织入，在织入切面时，AOP容器会为目标对象动态的创建一个代理对象。Spring AOP

Spring提供4种AOP支持
1.基于代理的经典AOP 只支持方法连接点
2.@AspectJ注解驱动的切面
3.纯POJO切面
4注入式AspectJ切面

1.经典AOP
代理类封装了目标类，并拦截被通知的方法的调用，再将调用转发给真正的目标Bean

2.AspectJ
Spring仅支持AspectJ切点指示器的一个子集，Spring是基于代理的，而某些切点表达式是与基于代理的AOP无关的
Spring AOP所支持的AspectJ切点指示器

arg() 指定类型的方法
@args() 指定注解标注的执行方法
execution() 用于匹配是连接点的执行方法
this() 限制连接点匹配AOP代理的Bean引用为指定类型的类
target() 匹配目标对象为指定类型的类
@target() 匹配特定的执行对象，对象对应的类要具备指定类型的注解
within() 匹配指定的类型
@within() 匹配注解所标注的类型
@annotation 匹配带有指定注解的连接点

编写切点

execution(*com.spring.springidol.Instrument.play(..))

execution() 方法返回时候触发（连接点的执行方法）
* 返回任意类型
com.spring.springidol.Instrument 方法所属的类
.play 此方法
(..) 参数匹配

如果仅仅匹配com.spring.springidol包
可以用within()指示器来限制匹配
execution(*com.spring.springidol.Instrument.play(..)) && within(com.spring.springidol.*)

&& || !都可以适用

bean()指示器
允许我们在切点表达式中使用Bean的ID来标识Bean bean使用 BeanID或Bean名称作为参数来限制切点只匹配特定的Bean

在执行Instrument的play() 方法时应用通知，但限定Bean的ID为eddie

execution(* com.spring.springidol.Instrument.play()) and bean(eddie)

声明环绕通知
如果不使用成员变量储存信息，那么在前置通知和后置通知之间共享信息非常麻烦,因为Audience是单例，如果像这样保存状态，它将存在现成安全问题
为了避免使用成员变量中保存开始时间，使用环绕通知在这点上有明显优势, 在一个方法内实现前置通知和后置通知所实现的相同功能，不需要使用成员变量。


public void watchPerformance(ProceedingJoinPoint JoinPoint){
long start = System.currentTimeMillis();  <- 之前
joinPoint.proceed();                      <- 执行方法
long end = System.currentTimeMillis();    <- 之后
}

ProceedingJoinPoint 能让我在通知里调用被通知方法
通知方法可以完成任何它所需要做的事情，而且如果希望把控制转给被通知的方法时, 我们可以调用ProceedingJoinPoint的proceed()方法

用于解决跨服务调用超时问题: 
hystrix:
  metrics:
    enabled: true
  command:
    default:
      execution:
        timeout:
          enabled: false

3. AOP 配置元素                                       描述
<aop: advsior>                  定义AOP通知器
<aop: after>                    定义AOP后置通知
<aop: after-returning>          定义AOP after-returning 通知
<aop: after-throwing> 			定义 after-throwing 通知
<aop: around>                   定义AOP环绕通知
<aop: aspect> 					定义切面
<aop: aspect-autoproxy> 		启动@AspectJ注解驱动的切面
<aop: before> 					定义 AOP前置通知
<aop: config> 					顶层的AOP配置元素, 大多的<aop:*> 元素必须包含在<aop:config> 元素内
<aop: declare-parents> 			为被通知的对象引入额外的接口，并透明的实现
<aop: pointcut> 				定义切点


前置声明和后置通知

<aop:config>
	<aop:aspect ref = "audience"> 
		<aop:before pointcut = "execution(* com.springinaction.springidol.Performer.perform(..))*"
			method="takeSeats" />
		<aop:after-returning pointcut= "execution(* com.springinaction.springidol.Performer.perform(..))"
			method="applaud" />
		<aop:after-throwing pointcut= "execution (* com.springinaction.springidol.Performer.perform(..))"
			method="demandRefund" />
	</aop: aspect> 
</aop:config> 	

为了避免重复定义切点，使用<aop: pointcut>元素定义一个命名切点
<aop:pointcut id="performance" expression= "*execution(*com.springinaction.springidol.Performer.perform(..))" />
引用该切点
<aop:before pointcut-ref="performance" method="takeSeats" />

4.4注解切面

@AspectJ进行标注

@Pointcut注解用于定义一个可以在@AspectJ切面内可重用的切点，注解的值是一个切点表达式

因为Audience类本身包含了所有它所需要定义的切点和通知，所以我们不需要在XML中配置声明的切点和通知。最后一件需要做的事是让Spring将
Audience应用为一个切面。我们需要在Spring上下文中声明一个自动代理Bean,该Bean如何把@AspectJ注解所标注的Bean转变为代理通知
为此Spring自带了名为AnnotationAwareAspectJAutoProxyCreator的自动代理创建类。我们需要在Spring上下文中把AnnotationAwareAspectJ
toProxyCreator注册为一个bean, 简化这样的操作，我们在aop命名空间中提供了<aop:aspectj-autoproxy/>，在Spring上下文中创建一个类，
它会自动代理一些bean. 

<aop:aspect> 相比于@AspectJ的优势是不需要源码

注解环绕通知 @Around 需要一个ProceedingJointPoint对象 作为方法入参，并在对象上调用proceed()方法

传递参数给所标注的通知
@Pointcut ("execution (* com.springinaction.springidol. ") + "Thinker.thinkOfSomething(String")) && args(thoughts)*)
public void thinking(String thoughts){}

@Before("thinking(thoughts")*)
public void interceptThoughts(String thoughts){
	System.out.println("Intercepting volunteer's thoughts: "+ thoughts);
	this.thoughts = thoughts;
} 

@DeclareParents 等价于 <aop:declare-parents> 

@AspectJ
public class ContestantIntroducer{

-----------引入Contestant接口-------------------
@DeclareParents(
value = "com.springinaction.springidol.Performer+". 
defaultImpl = "GraciousContestant.class"
)

public static Contestant contestant;
}

Contestant 为Performer Bean 引入了Contestant接口
@DeclareParents 注解3部分组成
value 属性等同于<aop:declare-parents>的types-matching属性，它标识应该被引入指定接口的Bean类型
defaultImpl属性等同于<aop:declare-parents>的default-impl属性。它标识该类提供所引入接口的实现
由@DeclareParents 注解所标注的static属性指定了将被引入的接口

4.5注入AspectJ切面

使用Spring 依赖注入把Bean装配进AspectJ切面中
public aspect JudgeAspect{
	public JudgeAspect(){}
	pointcut performance() : execution (* perform(..)); 
	after() returning() : performance(){
		System.out.println(criticismEngine.getCritism());
	}

	//injected
	private CriticismEngine criticismEngine;
	public void setCriticismEngine(CriticismEngine criticismEngine){
		this.criticismEngine = criticismEngine; 
	} 
}

JudgeAspect的主要职责是在表演之后为表演发表评论
JudgeAspect与一个CritismEngine对象协作，在表演结束时候，调用该对象的getCriticism()方法来发表一个评论
为了避免JudgeAspect和CritismEngine之间产生不必要的耦合，通过setter依赖注入为JudgeAspect赋予CriticismEngine

如下关系： 
			通知                 getCritism()
Performer  <------  JudgeAspect --------------> CritismEngine
						   ^					     ^
							\						 |					
							 \	注入进去				 |
							  \						 |
							   \				     |
								\ 			         |

								  CriticismEngineImple


切面也需要注入，如果AspectJ切面需要其他Bean, Spring也可以为AspectJ切面注入依赖

AspectJ切面不需要Spring就可以织入我们的应用中，但是如果想使用Spring的依赖注入为AspectJ切面注入协作者，那么就需要在Spring
配置中把切面声明为一个SpringBean. 如下的<bean> 声明会把criticismEngine bean注入到JudgeAspect中

<bean class = "com.sprininaction.springidol.JudgeAspect" factory-method = "aspectOf"
		<property name="criticismEngine" ref ="criticismEngine" /> 
</bean> 

通常情况下Spring Bean由Spring容器初始化, 但是AspectJ切面是由AspectJ在运行期创建的。等到Spring有机会为JudgeAspect注入
CriticismEngine时，JudgeAspect已经被实例化了。我们需要一种方式为Spring获得已经由AspectJ创建的JudgeAspect实例的句柄,从
而可以注入CriticismEngine. AspectJ提供了一个静态的aspectOf()方法, 该方法返回切面的一个单例. 

JudgeAspect装配CriticismEngineImpl，使用Spring注入为AspectJ切面注入协作者，那么就需要在Spring配置中把切面声明为一个Spring Bean
如下的<bean>声明会把criticismEngine Bean注入到Judge Aspect中

<bean class = "com.springinaction.springidol.JudgeAspect" factory-method= "aspectOf"
	<property name= " criticismEngine" ref = "criticismEngine" /> 
</bean>

简而言之，Spring不能使用<bean>声明来创建一个JudgeAspect实例-它已经在运行时候由AspectJ创建了。Spring通过aspectOf()工厂方法获得切面
的引用, 然后像<bean> 元素规定的那样在该对象上执行依赖注入

II Spring应用程序的核心组件

5.1 Spring的数据访问哲学

服务对象  ------> DAO接口 
				    ^
				    |
				    |
				    |
				    |
				 DAO实现

服务对象本身并不会处理数据访问, 而是将数据访问委托给DAO, DAO接口确保其与服务对象的松耦合。

好处  1.服务对象易于测试, 因为它们不再于特定的数据访问实现绑定在一起。
	  2.数据访问是以持久化技术无关的方式来进行访问的，持久化的选择独立于DAO, 只有相关的数据访问方法通过接口来进行发布.

了解Spring数据访问异常体系
Spring异常体系优于JDBC，几乎为读取和写入数据库所有错误都提供了异常，并不与特定的持久化方式相关联，意味着我们可以使用Spring
抛出一致的异常，而不用关系所选用的持久化方案。这有助于我们将所选择的持久化机制与数据访问层隔离开来。

JBDC异常                                                          Spring的数据访问异常

BatchUpdateException											CannotAcquireLockException
DataTruncation													CannotSerializeTransactionException
SQLException													CleanupFailureException
SQLWarning														ConcurrencyFailureException
																DataAccessException	
																DataAccessResourceFailureException
																DataIntegrityViolationException
																DataRetrieveFailureException
																DeadlockLoserDataAccessException
																EmptyResultDataAccessException
																IncorrectResultSizeDataAccessException
																IncorrectUpdateSemanticsDataAccessException
																InvalidDataAccessApiUsageException
																InvalidDataAccessResourceUsageException
																OptimisticLockingFailureException
																PermissionDeniedDataAccessException
																PessimisticLockingFailureException
																TypeMismatchDataAccessException
																UncategorizedDataAccessException

5.1.2 数据访问模板化

Spring将数据访问过程中固定的和可变的部分划分为:模板template和回调callback
Spring的模板类处理数据访问的固定部分-事务控制，管理资源及处理异常。应用程序相关的数据访问，在回调的实现中处理。

Spring的DAO模板类负责通用的数据访问功能，对于应用程序特定的任务，则会回调自定义的DAO回调对象

Spring的DAO模板负责通用的数据访问功能。对于应用程序的特定任务，则会调用自定义的DAO回调对象

1.准备资源 2.开始事务 3.在事务中执行 4. 返回数据 5提交/回滚事务 6.关闭资源和处理错误

针对不同的持久化平台, Spring提供了多个可选的模板。如果直接使用JDBC, 则可选择JDBC template, 如果希望使用对象关系映射框架
则用hibernate-template或JpaTemplate

模板类(org.springframework.*)                                   用途
jca.cci.core.CciTemplate                                       JCA CCI连接
jdbc.core.JdbcTemplate                                         JDBC连接
jdbc.core.namedparam.NamedParameterJdbcTemplate 			   命名参数的JDBC连接
jdbc.core.simple.SimpleJdbcTemplate							   Java5简化后的JDBC连接
orm.hibernate.HibernateTemplate								   Hibernate2.x的Session
orm.hibernate3.HibernateTemplate							   Hibernate3.x的Session
orm.ibatis.SqlMapClientTemplate								   iBATIS SqlMap客户端
orm.jdo.JdoTemplate											   Java数据对象(Java Data Object)的实现
orm.jpa.Template  											   Java持久化API的实体管理器


5.1.3 使用DAO支持类
基于模板-回调设计，Spring提供了DAO支持类，而将业务自己的DAO类作为它的子类

应用程序DAO -> DAO支持类 -> 数据访问模板 -> 持久化框架 -> 数据库

SpringDAO支持类提供了便携的方式来使用数据访问模板

DAO支持类 														为谁提供DAO支持
jca.cci.support.CciDaoSupport 								 	JCA CCI连接
jdbc.core.support.JdbcDaoSupport								JDBC 连接
jdbc.core.namedparam.NamedParameterJdbcDaoSupport				命名参数的JDBC连接
jdbc.core.simple.SimpleJdbcDaoSupport							Java5简化后的JDBC连接
orm.hibernate.support.HibernateDaoSupport						Hibernate2.x的Session
orm.hibernate3.support.HibernateDaoSupport						Hibernate3.x的Session
orm.ibatis.support.SqlMapClientDaoSupport						iBATIS SqlMap客户端
orm.jdo.support.JdoDaoSupport									Java数据对象(Java Data Object)的实现
orm.jpa.support.JpaDaoSupport									Java持久化API的实体管理器

5.2 配置数据源
不管选择哪一种Spring Dao的支持方式, 你可能都需要配置一个数据源的引用. Spring提供了在Spring上下文中配置数据源Bean
的多种方式, 包括： 
1. 通过JDBC驱动程序定义的数据源
2. 通过JNDI查找的数据源
3. 连接池的数据源

5.2.1使用JNDI数据源

Spring应用程序经常部署在Java EE应用服务器中, 如WebSphere, JBoss或者像Tomcat这样Web容器
利用Spring，我们可以像使用Spring Bean那样配置JNDI中数据源的引用并将其装配到需要的类中.
<jee:jndi-lookup id="dataSource" 
	jndi-name="/jdbc/SpitterDS"
	resources-ref="true" />

jndi-name用于指定JNDI资源中的名称，如果只设置了jndi-name属性，那么就会根据指定的名称查找数据源，
如果应用程序运行在java程序服务器中，则需要将resource-ref属性设置为true

5.2.2 使用数据源连接池

如果你不能从JNDI中查找数据源, 那么下一个选择就是直接在Spring中配置数据源连接池. DBCP包含了多个提供连接池功能的数据源
,其中BasicDataSource	是最常用的


BasicDataSource的池配置属性								所指定的内容	  					
initalSize												池启动时创建的连接数量
maxActive												同一时间可从池中分配的最多连接数，如果设置为0，表示无限制
maxIdle													池里不会被释放的最多空间连接数，如果设置为0，表示无限制 
maxOpenPreparedStatements								在同一时间能够从语句池中分配的预处理语句最大数量，如果设置为0，表示无限制 			
maxWait													在抛出异常前，池等待连接回收的最大时间,设置-1表示无限等待						
minEvictableTimeMillis									连接池中保持空闲而不被收回的最大时间			
minIdle													在不创建新连接的情况下，池中保持空闲的最小连接数 
poolPreparedStatements									是否对预处理语句进行池管理(boolean)

JDBC驱动的数据源

通过JDBC定义驱动是最简单的方式, Spring提供了两种数据源对象供选择
DriverManagerDataSource: 在每个连接请求时，都会返回一个新建的连接，不进行池化管理
SingleConnectionDataSource: 在每个连接请求时都会返回同一个连接。尽管SingleConnectionDataSource不是严格 意义上的连接池数据源,
但是可以视为只有一个连接的池

SingleConnectionDataSource不适用于多线程的应用程序，DriverManagerDataSource支持多线程，但是在每次请求连接时候都会创建新连接
以性能为代价，所以强烈建议使用数据源连接池

5.4在Spring中集成Hibernate

延迟加载(Lazy load)
借助延迟加载，我们可以只抓取需要的数据

预先抓取(Eager fetching)
借助预先抓取，我们可以使用一个查询获取完整的关联对象，预先抓取的功能可以在一个操作中将他们全部从数据库中提取出来，节省了多次查询的成本

级联(Cascading)
有时，更改数据库同时会修改其他表，我们希望一次操作能将关联的表多表修改

ORM(object-relational mapping)
Spring对ORM框架的支持提供了这些框架的集成点以及一些附加的服务
*Spring声明式事务的集成支持
*透明的异常处理
*线程安全，轻量级模板类 
*DAO支持类
*资源管理

5.4.1 Hibernate概览

在Spring应用程序中使用Hibernate是通过HibernateTemplate进行的，HibernateTemplate简化了使用Hibernate的繁琐工作，
并且是通过捕获Hibernate特定的异常，然后转换成Spring的非检查型数据库访问异常并重新抛出而实现的

HibernateTemplate职责之一是管理Hibernate的Session，这涉及打开和关闭Session并确保每个事务使用相同的Session，如果
没有HibernateTemplate, 我们只能让自己的DAO充满了Session管理的样板代码

HibernateTemplate的不足之处在于存在一定程度的入侵性. 当我们在DAO中使用HibernateTemplate时，DAO类就会与Spring API
产生耦合

Hibernate3引入上下文Session(Contextual Session)，这是Hibernate本身所提供的保证每个事务使用同一Session的方案，因此
没有必要使用HibernateTemplate保证这一行为了。在使用Hibernate Contextual Session之前，我们需要为Hibernate做一些准备
工作即在Spring里配置Session Factory

5.4.2 声明Hibernate的Session工厂

使用Hibernate的主要接口时org.hibernate.Session. Session接口提供了基本数据访问功能，CRUD以及从数据库加载对象功能.
标准方式是借助于Hibernate的SessionFactory接口实现类。除了一些其他的任务，SessionFactory主要负责Hibernate Session
的打开，关闭以及管理.

在Spring中，我们要通过Spring的某一个Hibernate Session工厂Bean来获取Hibernate的SessionFactory.我们可以在应用程序
的Spring上下文中，像配置其他Bean那样来配置Hibernate Session工厂

在配置Hibernate Session工厂Bean的时候，我们需要确定持久化域名对象是通过XML文件还是通过注解来进行配置的, 如果你更倾向
用注解的方式来定义持久化，那需要使用AnnotationSessionFactoryBean来替代LocalSessionFactoryBean

dataSource声明从哪里获得数据库连接
hibernateProperties声明了要使用哪一种数据库
packagesToScan属性告诉Spring扫描一个或多个包以查找域类，这些类通过注解方式表明要使用Hibernate进行持久化。
JPA的@Entity 或者 @MapperSuperClass 注解以及Hibernate的@Entity 注解进行标注的类都会包含在内

anntotatedClasses属性将应用程序所以持久化类以全限定名的方式明确列出，annototatedClasses属性对于准确指定少量的域类是
不错的选择。如果你有很多的域类且不想将其全部列出，或者你想自由的添加移除域类而不想修改Spring配置的话,则使用packageToScan
更合适

5.4.3 构建不依赖于Spring的Hibernate 代码

在没有上下文时候，Spring的Hibernate模板用于保证每个事务使用同一个Session. 既然Hibernate自己能够对其进行管理, 那就没有
必要使用模板类了。意味着能直接将Hibernate装配到DAO中

@Repository
public class HibernateSpitterDao implements SpitterDao{
	private SessionFactory sessionFactory;

	@Autowired
	public HibernateSpitterDao(SessionFactory sessionFactory){
		this.sessionFactory = sessionFactory;                     <------ 构造DAO
	}

	private Session currentSession(){
		return sessionFactory.getCurrentSession();            <----- 从SessionFactory中获取当前Session
	}

	private void addSpitter(Spitter spitter){					<------ 使用当前的Session
		currentSession().save(spitter);                      
	}

	public Spitter getSpitterById(long id){
		return (Spliter) currentSession().get(Spitter.class, id);           <------ 使用当前的Session
	}

	public void saveSpitter(Spitter spitter){
		currentSession.update(spitter);
	}
}

@Autowired 注解可以让Spring自动将一个SessionFactory注入到HibernateSpitterDao的sessionFactory属性中
接下来在currentSession()方法中，使用这个SessionFactory来获取当前事务的Session.

@Repository 注解能够像其他注解一样被<context:component-scan>所扫描到, 这样不必明确声明HibernateSpitterDao
Bean了.
不适用模板的Hibernate DAO添加异常转换功能,我们只需在Spring应用上下文中添加一个PersistenceExceptionTranslation
PostProcessor Bean.

PersistenceExceptionTranslationPostProcessor是一个Bean的后置处理程序, 它会在所有拥有@Respository注解的类上
添加一个通知器advsior, 这样就能捕获任何平台相关的异常并以Spring 非检查型数据访问异常的形式抛出

5.5 Spring 与Java 持久化 API

5.5.1 配置实体管理工厂
基于JPA的应用程序 使用EntityManagerFactory的实现类来获取EntityManager实例 JPA定义了两种类型的实体管理器

应用程序类管理器 Application-managed: 当应用程序向实体管理器工厂直接请求实体管理器时，工厂会创建一个实体管理器。
在这种模式下，程序要负责打开或关闭实体管理器并在事务中对其进行控制。 这种方法的实体管理器适合不运行在Java EE容器中
独立的应用程序

容器管理器 Container-managed: 实体管理器是由Java EE创建和管理. 应用程序根本不与实体管理器工厂打交道. 相反，实体管理器
直接通过注入或者JNDI来获取。容器负责配置实体管理器工厂。这种类型的实体管理器最适合用于Java EE的容器。

以上两种实体管理器实现了同一个EntityManager接口。关键区别不在于EntityManager本身，而是在于EntityManager的创建和管理方式
应用程序管理类型的EntityManager是由EntityManagerFactory所创建的，而后者是通过PersistenceProvider的createEntityManager
Factory()方法得到的

这两种实体管理器工厂分别由对应的Spring工厂Bean创建

LocalEntityManagerFactoryBean 生成应用程序管理类型的EntityManagerFactory
LocalContainerEntityManagerFactoryBean 生成容器管理类型的EntityManagerFactory

使用应用程序管理类型的JPA
使用容器管理类型的JPA

5.5.2 编写基于JPA的DAO

正如Spring对其他持久化方案的集成，Spring对JPA的集成也提供了JpaTemplate模板以及对应的支持类JpaDaoSupport
不使用Spring JpaTemplate的DAO

@Repository(*spitterDao*)
@Transactional
public class JpaSpitterDao implements SpitterDao {
	private static final String RECENT_SPITTERS = *SELECT s FROM Spittle s*;
	private static final String ALL_SPITTERS = *SELECT s FROM Spittle s WHERE s.username = :username*;

	@PersistenceContext
	private EntityManager em;                   <------ 注入EntityManager

	public void addSpitter(Spitter spitter){
		em.persist(spitter);                    <------使用EntityManager   
	}

	public Spitter getSpitterById(long id){
		return em.find(Spitter.class, id);       <------使用EntityManager   
	}
}

JpaSpitterDao使用了EntityManager处理持久化。通过使用EntityManager, Dao非常干净并且干起来就像没有使用Spring的
DAO, em使用了@PersistentContext 注解，表明需要在Spring应用上下文配置一个PersistenceAnnotationBeanPostProcessor

6 事务管理

ACID 
原子性 Atomic 事务是由一个或多个活动组成的一个工作单元，原子性确保事务中所有操作全部发生或者全部不发生
一致性 Consistenct 一旦事务完成，系统必须确保它所建模的业务处于一致的状态。现实的数据不应该被破坏
隔离性 Isolated 事务允许多个用户对相同的数据进行操作，每个用户的操作不会与其他用户纠缠在一起
持久性 Durable 一旦事务完成，事务的结果应该持久化，这样就能从任何崩溃的系统中恢复过来

6.2 选择事务管理器

Spring并不直接管理事务，而是提供了多种事务管理器，它们将事务管理的职责委托给JTA或其他持久化机制所提供的平台
相关的事务实现

事务管理器(org.framework.*)								使用场景
jca.cci.connection.CciLocalTransactionManager		使用Spring 对JavaEE连接器架构和通用客户端接口提供支持
jdbc.datasource.DataSourceTransactionManager 	用于Spring对JDBC抽象的支持也可也用于使用iBatis进行持久化的场景                        
jms.connection.JmsTransactionManager 			用于JMS1.1+
jms.connection.JmsTranscationManager102			用于JMS1.0.2
orm.hibernate3.HibernateTranscationManager		用于Hibernate3进行持久化
orm.jdo.JdoTransactionManager 					用于JDO进行持久化
orm.jpa.JpaTransactionMagaer 					用于Java持久化API
transaction.jta.JtaTransactionManager			需要分布式事务或者没有其他的事务管理器满足需求
transaction.jta.OC4JJtaTransactionManager		用于Oracle的OC4J JEE容器
transaction.jta.WebLogicJtaTransactionManager	需要分布式事务并且程序应用于WebLogic中
transaction.jta.WebSphereUowTranscationManager	需要WebSphere中UOWManager所管理的事务

JDBC事务
如果在应用程序中直接使用JDBC来进行持久化 DataSourceTransactionManager会为你处理事务边界，要注意的是dataScource属性值
配置成了一个名为dataSource bean的引用。而dataSource是定义在上下文文件中javax.sql.DataSource Bean.

Hibernate事务
如果应用程序通过Hibernate实现的，那么你需要使用HibernateTranscationManager。 sessionFactory属性需要装配一个Hibernate 
SessionFactory

JPA事务
如果使用JPA, 使用Spring中的JpaTranscationManager来处理事务, JpaTransactionManager只需要装配一个JPA实体管理工厂.
JPATransactionManager将于工厂产生的JPA EntityManager合作来构建事务
除了将事务应用于JPA操作，JpaTranscationManager还支持将事务应用于简单的JDBC操作中,这些JDBC操作所使用的DataSource与
EntityManagerFactory所使用的DataSource必须是相同的。为了做到这一点，JpaTransactionManager必须装配一个JpaDialect的
实现，然后你还需要将jpaDialect Bean装配到JpaTransactionManager中

添加事务的一种方式是在saveSpittle()方法中直接通过编码使用Spring的TransactionTemplate来添加事务性边界。

public void saveSpittle(final Spittle spittle){
	txTemplate.execute(new TransactionCallback<Void>(){
		public void doInTransaction(TranscationStatus txStatus){
			try{
				spitterDao.saveSpittle(spittle);
			}catch(RuntimeException e){
				txStatus.setRollbackOnly();
				throw e;
			}
			return null;
		}
	})
}

为了使用TranscationTemplate, 你需要实现TransactionCallback接口，因为TransactionCallback只有一个要实现的方法，通常使用内部
匿名类，放在doInTranscation()中.

调用TransactionTemplate实例的execute方法时, 将会执行TransactionCallback实例中的代码.如果代码遇到问题，调用TranscationStatus
对象的setRollbackOnly()方法将回滚事务，否则如果doInTransaction()成功返回, 事务将会成功提交.

6.4.1定义事务属性

声明式事务是通过事务属性来定义的

1. 传播行为(propagation behavior)								

定义了何时要创建一个事务或者何时使用已有的事务

传播行为														含义

PROPAGAGTION_MANDATORY 				表示该方法必须在事务中运行，当前事务不存在，则抛出异常
PROPAGAGTION_NESTED					存在一个事务，改方法会在嵌套事务中运行，嵌套事务可以独立于当前事务进行回滚，如果当前事务不存在
									则行为与PROPAGATION_REQUIRED一样
PROPAGATION_NEVER					表示当前方法不应该运行在事务上下文当中，如果当前正有事务在运行，抛出异常
PROPAGATION_NOT_SUPPORT				表示方法不应该运行在事务中，如果在当前事务，该方法运行期间，事务将会被挂起
PROPAGATION_REQUIRED 				表示方法必须允许与事务中，当前事务存在，则运行于当前事务，否则另起一个新事务
PROPAGATION_REQUIRED_NEW			表示当前方法必须运行在它自己的事务中，一个新的事务将被启动，如果存在当前事务，
									则在该方法执行期间，事务会被挂起
PROPAGATION_SUPPORTS 				表示当前方法不需要事务上下文，但是如果存在当前事务的话，那么该方法会在这个事务中运行

2. 隔离级别 

定义了一个事务可能受其他并发事务影响的程度

脏读 Dirty Reads
脏读发生在一个事务读取了另一个事务改写但尚未提交数据时候,如果改写在稍后被回滚了，那么第一个事务获取的数据就是无效的

不可重复读 Nonrepeatable read 
发生在一个事务执行查询两次或者两次以上，但是每次都得到不同的数据，通常因为另一个并发事件在两次查询期间更新了数据

幻读 Phantom read
一个事务读取了几行数据，接着另一个并发事务插入了一些数据时，在随后的查询中第一个事务就会发现多了一些原本不存在的事务

隔离级别														含义
ISOLATION_DEFAULT										默认隔离级别
ISOLATION_READ_UNCOMMITTED								允许读取尚未提交的数据变更，可能会导致脏读，幻读，不可重复读
ISOLATION_READ_COMMITTED								允许读取并发事务以及提交的数据，可以阻止脏读，但是会有幻读和不可重复读
ISOLATION_REPEATABLE_READ								对同一字段的多次读取结果一致的，除非数据是被本事务所修改，
														可以阻止脏读和不可重复读, 但是仍有可能发生幻读
ISOLATION_SERILAIZABLE									完全服从ACID的隔离级别

3. 只读

4. 事务超时 

5.回滚原则

事务五边形5各方面通过该元素属性来指定

属性 														含义
isolation 												指定事务的隔离级别
propagation 											定义事务的传播规则
read-only												只读
rollback-for/no-rollback-for							回滚原则
timeout													超时

定义注解驱动事务

@Transactional(propagation = Propagation.SUPPORTS, readOnly= true)

7 Spring MVC

7.1.1 跟踪Spring MVC的请求

SpringMVC的核心是DispatcherServerlet, 这个Servlet充当SpringMVC的前端控制器

<servelet-name> DispatchServerlet加载时会从一个基于这个Serverlet名字的XML文件中加载Spring应用上下文
必须声明DispatchServerlet处理哪些URL，比较常见DispatchServerlet匹配模式是*.htm, /*, 或者/app 

*htm 隐式表明响应始终是HTML格式的
/*将其匹配的话没有映射特定的响应，它表明DispatcherServelet将处理所有的请求
/app模式 帮助我们区分了DispatcherServerlet处理的内容和其他内容，但这样就会在URL中暴露了实现的细节

建议使用/模式

编写基本的控制器

Web浏览器                  其他客户端
	\                         /
	 \                       / 
	  \						/
	   \				   /	
	   	  Web (controller)
	   	  		|	
	   	  		|
	   	  		|
	   	  		|
			 Service     --------- Domain
				|
				|
				|
				|
			Persistence		
				|
				|
				|
				|
			Data Store
			
7.2.1 配置注解驱动的Spring MVC 
DispatchServerlet需要咨询一个或者多个处理器映射来明确将请求分发给哪个控制器

Spring 自带了多个处理器映射供我们选择如下: 

BeanNameUrlHandlerMapping: 根据控制器名字映射到URL
	