Spring采用以下4种关键策略降低Java开发的复杂性：
1. 基于POJO的轻量级和最小入侵性编程
2. 通过依赖注入和面向接口实现松耦合
3. 基于切面和惯例进行声明式编程
4. 通过切面和模版减少样板代码


装配Bean
1. 创建Spring配置
 Spring是一个基于容器的框架，我们需要配置Spring来告诉它需要加载哪些Bean和如何装配这些Bean
 两种配置Bean的方式
 1.XML文件
 2.Java注解

Bean在XML中的位置
在XML文件中声明Bean，Spring配置文件的根元素是来源于Spring Bean命名空间所定义的<bean>元素：
<beans xmlns=""
      xmlns:xsi=""
      xsi:schemaLocation="">
      <!-- bean declarations go here -->
</beans>

Java自带多种XML命名空间，通过这些命名空间可以配置Spring容器
aop 声明切面以及将@AspectJ注解的类代理为Spring切面提供配置元素
beans 支持声明Bean和装配Bean
context 为配置Spring 应用上下文提供了配置元素，包括自动检测和自动装配Bean,注入非Spring直接管理的对象
jee 为声明消息驱动的POJO提供了配置元素
lang 配置由Groovy, JRuby, BeanShell等脚本实现的Bean
mvc 启动Spring MVC的能力 例如面向注解的控制器, 视图控制器，和拦截器
oxm 支持Spring对象到XML的映射配置
tx 提供声明式事物配置
util 工具类元素

声明一个Bean

<bean id="duke
      class="om.spring.springidol.Juggler" />

      <bean> 元素是Spring中最基本的配置单元，通过该元素Spring将创建一个对象。id属性定义了Bean的名字，也作为Bean在Spring容器中的引用.

通过构造器注入

1. 使用默认的构造器
2. 带一个int参数的构造方法

XML声明方式
<bean id="duke"
      class="com.spring.springidol.Juggler">
      <constructor-arg value= "15"/>
</bean>

扩展成一个PoeticJuggler
<bean id="duke"
      class="com.spring.springidol.Juggler">
      <constructor-arg value= "15"/>
      <constructor-arg ref="sonnet29" />
</bean>
逻辑类似于
Poem sonnet29 = new sonnet29();
Performer duke = new PoeticJuggler(15, sonnet29);

通过工厂方式创建Bean
Spring 支持通过<bean>元素的factory-method属性来装配工厂创建的Bean
<bean id= "theStage"
      class = "com.spring.springidol.Stage"
      factory_method = "getInstance" />

Bean的作用域
所有的Bean默认都是单列

如何让容器分配Bean时，每次请求都产生一个新的实例？
只需要配置Bean的scope属性为prototype即可
<bean id="ticket"
      class="com.spring.springidol.Ticket" scope = "prototype"/>
其他的作用域选项
singleton 在每一个Spring容器中，一个Bean定义只有一个对象实例 默认
prototype 允许Bean被实例化任意次
request 在一次HTTP请求中，每个Bean定义对应一个实例 仅web有效
session 一个HTTP session中 每个Bean对应一个实例 仅web有效

Bean的初始化和销毁
使用 init-method和destroy method参数来配置<bean>元素
<bean id = "auditorium"
      class = "com.spring.springidol.Auditorium"
      init-method = "turnOnLights"
      destroy-method = "turnOffLights" />
另一种方案是实现InitializingBean和DisposableBean接口

注入Bean属性
简单的赋值 使用property标签
<bean id="kenny"
      class = "com.spring.springidol.Instrumentalist"
      <property name = "song" value = "Jingle Bells" />
</bean>

用其他Bean赋值 使用ref
<bean id="kenny2"
      class ="come.spring.springidol.Instrumentalist">
      <property name = "song" value ="Jingle Bells"
      <property name = "instrument" ref = "saxophone" />
</bean>
调用Bean
ApplicationContext ctx = new ClassPathXmlApplicationContext("com/spring/springidol/spring-idol.xml");
Performer performer = (Performer) ctx.getBean("kenny");
performer.perform();

注入内部Bean

<bean id="kenny"
      class = "com.spring.springidol.Instrumentalist">
      <property name = "song" value = "Jingle Bells" />
      <property name = "instrument">
        <bean class= "springinaction.springidol.Saxophone" />
      </property>
</bean>

装配集合

<list> 装配list类型的值
<set> 装配set类型的值 不允许重复
<map> 装配map类型的值 名称和值可以是任意类型
<props> 装配properties类型的值 名称和值都必须是String型

2.3 使用表达式装配
Spring Expression Language SpEL 一种强大简洁的装配方式

3.最小化Spring XML配置

自动装配 autowiring 减少<property> 元素和 <constructor-arg> 元素
自动检测 autodiscovery 更进一步自动识别哪些类需要配置为bean

4种类型的自动装配

byName 把与Bean属性具有相同名字(或id)的其他Bean自动装配到Bean对应的属性中
byType 把与Bean属性具有相同类型的其他Bean自动装配到该Bean的对应属性中
constructor 把与Bean的const 具体相同类型的其他Bean自动装配到Bean构造器对应args中
autodetect 首先尝试用const进行装配失败了尝试byType

3.2使用注解装配

Spring容器默认禁用注解装配 在使用基于注解的自动装配前 需要在Spring配置中启动它，
<context:annotation-config>

3种自动装配注解
1. @Autowired
2. @Inject
3. @Resource

1.@Autowired
可以对方法进行标注
@Autowired
public void setInstrcument(Instrument instrument){
	this.instrucment = instrucment
}
可以对构造器进行标注
@Autowired
public Instrumentalist(Instrument instrument){
	this.instrucment = instrucment
}
可以直接标注属性
@Autowired
private Instrument instrument;

可选的自动装配
1. 强契约，所标注的属性或者参数必须是可以装配的
2. Null 也可以接受 @Autowired(required = false)

多个Bean满足装配条件时，使用@Qualifier注解
@Autowired
@Qualifier("guitar")
private Instrument instrument;

还可以使用@Qualifier标注Guitar类
@Qualifier("stringed")
public class Guitar implements Instrument{
	...
}

创建自定义的限定器(Qualifier)

创建@Stringedinstrument注解来充当限定器

@Target({ElementType.FIELD, ElementType.PARAMETER, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Qualifier
public @interface StringInstrument{...}

可以用它来代替Qualifier

@StringedInstrument
public class Guitar implements Instrument{...}

2.@Inject
类似Autowired

3.注解中使用表达式
@Value("Eruption")
private String song;

@Value("#{SystemProperties.myFavoriteSong}")
private String song;

自动检测Bean
<context:component-scan> 允许Spring自动检测Bean和定义Bean

标注Bean
@Component 通用的构造型组件，标识为Spring组件
@Controller 标识为SpringMVC里的controller
@Repository 标识为数据仓库
@Service 标识该类为服务

过滤组件扫描
<context: include-filter> 的type和expression属性一起协作来定义组件扫描策略
过滤器类型
1.annotation 过滤器扫描使用指定注解所标注的类，通过expression属性指定要扫描的注解
2.assignable 过滤器扫描派生于expression属性所指定的类型的那些类
3.aspectj  过滤器扫描与expression属性所指定的AspectJ表达式所匹配的那些类
4.custom 自定义
5.regex 扫描正则表达式匹配的类

3.4 使用Spring基于Java的配置
在基于Java配置里使用@Configuration注解的Java类，就等价于XML配置中的<bean>元素

定义一个配置类
在基于Java的配置里使用@Configuration注解的Java类就等价于XML配置中的<beans>元素

@Configuration
public class SpringIdolConfig{
  //Bean declaration methods go here
}

@Configuration注解作为一个标识告知Spring：这个类包含一个或多个Spring Bean的定义，这些Bean定义是使用@Bean注解所标注的方法

声明一个简单的Bean
使用@Bean注解标注一个方法来定义duke Bean

@Bean
public Performer duke(){
  return new Juggler();
}

使用Spring基于Java的配置进行注入

使用Spring基于Java编写一个返回类实例的方法 直接传值
为Bean装配另一个Bean的引用

@Bean
public Performer poeticDuke(){
  return new PoeticJuggler(sonnet29());
}
不会让方法产生新的实例

4. 面向切面的Spring

通知（Advice)
5种类型
Before 在方法被调用之前调用通知
After 在方法完成后调用通知, 无论方法执行成功与否
After-returning 在方法成功执行之后调用通知
After-throwing 在方法抛出异常之后调用通知
Around 通知包裹了被通知的方法，在被通知的方法调用之前和调用之后 执行自定义的行为

连接点（JoinPoint)
连接点是在应用执行的过程中能够插入切面的一个点，这个点可以是调用方法，抛出异常，修改字段时，切面代码可以利用这些点插入到应用的正常流程之中，
并添加新的行为

切点（Pointcut)
切点的定义会匹配通知所要织入的一个或多个连接点，通常使用明确的类和方法名称来指定这些切点，或者是利用正则表达式定义匹配的类和方法名称

切面 （Aspect）
切面是通知和切点的结合

引入（Introduction）
引入允许我们向现有的类添加新的方法和属性

织入（Weaving）
织入是将切面应用到目标对象来创建新的代理对象的过程。切面在指定的连接点被织入到目标对象中，在目标对象的生命周期里有多个点可以进行织入。

编译期-切面在目标类编译时被织入,比如ApsectJ织入编译器

类加载器-切面在目标类加载到JVM时被织入

运行期-切面在应用运行的某个时刻被织入，在织入切面时，AOP容器会为目标对象动态的创建一个代理对象。Spring AOP

Spring提供4种AOP支持
1.基于代理的经典AOP 只支持方法连接点
2.@AspectJ注解驱动的切面
3.纯POJO切面
4注入式AspectJ切面

1.经典AOP
代理类封装了目标类，并拦截被通知的方法的调用，再将调用转发给真正的目标Bean

2.AspectJ
Spring仅支持AspectJ切点指示器的一个子集，Spring是基于代理的，而某些切点表达式是与基于代理的AOP无关的
Spring AOP所支持的AspectJ切点指示器

arg() 指定类型的方法
@args() 指定注解标注的执行方法
execution() 用于匹配是连接点的执行方法
this() 限制连接点匹配AOP代理的Bean引用为指定类型的类
target() 匹配目标对象为指定类型的类
@target() 匹配特定的执行对象，对象对应的类要具备指定类型的注解
within() 匹配指定的类型
@within() 匹配注解所标注的类型
@annotation 匹配带有指定注解的连接点

编写切点

execution(*com.spring.springidol.Instrument.play(..))

execution() 方法返回时候触发（连接点的执行方法）
* 返回任意类型
com.spring.springidol.Instrument 方法所属的类
.play 此方法
(..) 参数匹配

如果仅仅匹配com.spring.springidol包
可以用within()指示器来限制匹配
execution(*com.spring.springidol.Instrument.play(..)) && within(com.spring.springidol.*)

&& || !都可以适用

bean()指示器
允许我们在切点表达式中使用Bean的ID来标识Bean bean使用 BeanID或Bean名称作为参数来限制切点只匹配特定的Bean

在执行Instrument的play() 方法时应用通知，但限定Bean的ID为eddie

execution(* com.spring.springidol.Instrument.play()) and bean(eddie)

声明环绕通知
如果不使用成员变量储存信息，那么在前置通知和后置通知之间共享信息非常麻烦,因为Audience是单例，如果像这样保存状态，它将存在现成安全问题
为了避免使用成员变量中保存开始时间，使用环绕通知在这点上有明显优势, 在一个方法内实现前置通知和后置通知所实现的相同功能，不需要使用成员变量。


public void watchPerformance(ProceedingJoinPoint JoinPoint){
long start = System.currentTimeMillis();  <- 之前
joinPoint.proceed();                      <- 执行方法
long end = System.currentTimeMillis();    <- 之后
}

ProceedingJoinPoint 能让我在通知里调用被通知方法
通知方法可以完成任何它所需要做的事情，而且如果希望把控制转给被通知的方法时, 我们可以调用ProceedingJoinPoint的proceed()方法

用于解决跨服务调用超时问题: 
hystrix:
  metrics:
    enabled: true
  command:
    default:
      execution:
        timeout:
          enabled: false

3. AOP 配置元素                                       描述
<aop: advsior>                  定义AOP通知器
<aop: after>                    定义AOP后置通知
<aop: after-returning>          定义AOP after-returning 通知
<aop: after-throwing> 			定义 after-throwing 通知
<aop: around>                   定义AOP环绕通知
<aop: aspect> 					定义切面
<aop: aspect-autoproxy> 		启动@AspectJ注解驱动的切面
<aop: before> 					定义 AOP前置通知
<aop: config> 					顶层的AOP配置元素, 大多的<aop:*> 元素必须包含在<aop:config> 元素内
<aop: declare-parents> 			为被通知的对象引入额外的接口，并透明的实现
<aop: pointcut> 				定义切点


前置声明和后置通知

<aop:config>
	<aop:aspect ref = "audience"> 
		<aop:before pointcut = "execution(* com.springinaction.springidol.Performer.perform(..))*"
			method="takeSeats" />
		<aop:after-returning pointcut= "execution(* com.springinaction.springidol.Performer.perform(..))"
			method="applaud" />
		<aop:after-throwing pointcut= "execution (* com.springinaction.springidol.Performer.perform(..))"
			method="demandRefund" />
	</aop: aspect> 
</aop:config> 	

为了避免重复定义切点，使用<aop: pointcut>元素定义一个命名切点
<aop:pointcut id="performance" expression= "*execution(*com.springinaction.springidol.Performer.perform(..))" />
引用该切点
<aop:before pointcut-ref="performance" method="takeSeats" />

4.4注解切面

@AspectJ进行标注

@Pointcut注解用于定义一个可以在@AspectJ切面内可重用的切点，注解的值是一个切点表达式

因为Audience类本身包含了所有它所需要定义的切点和通知，所以我们不需要在XML中配置声明的切点和通知。最后一件需要做的事是让Spring将
Audience应用为一个切面。我们需要在Spring上下文中声明一个自动代理Bean,该Bean如何把@AspectJ注解所标注的Bean转变为代理通知
为此Spring自带了名为AnnotationAwareAspectJAutoProxyCreator的自动代理创建类。我们需要在Spring上下文中把AnnotationAwareAspectJ
toProxyCreator注册为一个bean, 简化这样的操作，我们在aop命名空间中提供了<aop:aspectj-autoproxy/>，在Spring上下文中创建一个类，
它会自动代理一些bean. 

<aop:aspect> 相比于@AspectJ的优势是不需要源码

注解环绕通知 @Around 需要一个ProceedingJointPoint对象 作为方法入参，并在对象上调用proceed()方法

传递参数给所标注的通知
@Pointcut ("execution (* com.springinaction.springidol. ") + "Thinker.thinkOfSomething(String")) && args(thoughts)*)
public void thinking(String thoughts){}

@Before("thinking(thoughts")*)
public void interceptThoughts(String thoughts){
	System.out.println("Intercepting volunteer's thoughts: "+ thoughts);
	this.thoughts = thoughts;
} 

@DeclareParents 等价于 <aop:declare-parents> 

@AspectJ
public class ContestantIntroducer{

-----------引入Contestant接口-------------------
@DeclareParents(
value = "com.springinaction.springidol.Performer+". 
defaultImpl = "GraciousContestant.class"
)

public static Contestant contestant;
}

Contestant 为Performer Bean 引入了Contestant接口
@DeclareParents 注解3部分组成
value 属性等同于<aop:declare-parents>的types-matching属性，它标识应该被引入指定接口的Bean类型
defaultImpl属性等同于<aop:declare-parents>的default-impl属性。它标识该类提供所引入接口的实现
由@DeclareParents 注解所标注的static属性指定了将被引入的接口

4.5注入AspectJ切面

使用Spring 依赖注入把Bean装配进AspectJ切面中
public aspect JudgeAspect{
	public JudgeAspect(){}
	pointcut performance() : execution (* perform(..)); 
	after() returning() : performance(){
		System.out.println(criticismEngine.getCritism());
	}

	//injected
	private CriticismEngine criticismEngine;
	public void setCriticismEngine(CriticismEngine criticismEngine){
		this.criticismEngine = criticismEngine; 
	} 
}

JudgeAspect的主要职责是在表演之后为表演发表评论
JudgeAspect与一个CritismEngine对象协作，在表演结束时候，调用该对象的getCriticism()方法来发表一个评论
为了避免JudgeAspect和CritismEngine之间产生不必要的耦合，通过setter依赖注入为JudgeAspect赋予CriticismEngine

如下关系： 
			通知                 getCritism()
Performer  <------  JudgeAspect --------------> CritismEngine
						   ^					     ^
							\						 |					
							 \	注入进去				 |
							  \						 |
							   \				     |
								\ 			         |

								  CriticismEngineImple


切面也需要注入，如果AspectJ切面需要其他Bean, Spring也可以为AspectJ切面注入依赖

