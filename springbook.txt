Spring采用以下4种关键策略降低Java开发的复杂性：
1. 基于POJO的轻量级和最小入侵性编程
2. 通过依赖注入和面向接口实现松耦合
3. 基于切面和惯例进行声明式编程
4. 通过切面和模版减少样板代码


装配Bean
1. 创建Spring配置
 Spring是一个基于容器的框架，我们需要配置Spring来告诉它需要加载哪些Bean和如何装配这些Bean
 两种配置Bean的方式
 1.XML文件
 2.Java注解

Bean在XML中的位置
在XML文件中声明Bean，Spring配置文件的根元素是来源于Spring Bean命名空间所定义的<bean>元素：
<beans xmlns=""
      xmlns:xsi=""
      xsi:schemaLocation="">
      <!-- bean declarations go here -->
</beans>

Java自带多种XML命名空间，通过这些命名空间可以配置Spring容器
aop 声明切面以及将@AspectJ注解的类代理为Spring切面提供配置元素
beans 支持声明Bean和装配Bean
context 为配置Spring 应用上下文提供了配置元素，包括自动检测和自动装配Bean,注入非Spring直接管理的对象
jee 为声明消息驱动的POJO提供了配置元素
lang 配置由Groovy, JRuby, BeanShell等脚本实现的Bean
mvc 启动Spring MVC的能力 例如面向注解的控制器, 视图控制器，和拦截器
oxm 支持Spring对象到XML的映射配置
tx 提供声明式事物配置
util 工具类元素

声明一个Bean

<bean id="duke
      class="om.spring.springidol.Juggler" />

      <bean> 元素是Spring中最基本的配置单元，通过该元素Spring将创建一个对象。id属性定义了Bean的名字，也作为Bean在Spring容器中的引用.

通过构造器注入

1. 使用默认的构造器
2. 带一个int参数的构造方法

XML声明方式
<bean id="duke"
      class="com.spring.springidol.Juggler">
      <constructor-arg value= "15"/>
</bean>

扩展成一个PoeticJuggler
<bean id="duke"
      class="com.spring.springidol.Juggler">
      <constructor-arg value= "15"/>
      <constructor-arg ref="sonnet29" />
</bean>
逻辑类似于
Poem sonnet29 = new sonnet29();
Performer duke = new PoeticJuggler(15, sonnet29);

通过工厂方式创建Bean
Spring 支持通过<bean>元素的factory-method属性来装配工厂创建的Bean
<bean id= "theStage"
      class = "com.spring.springidol.Stage"
      factory_method = "getInstance" />

Bean的作用域
所有的Bean默认都是单列

如何让容器分配Bean时，每次请求都产生一个新的实例？
只需要配置Bean的scope属性为prototype即可
<bean id="ticket"
      class="com.spring.springidol.Ticket" scope = "prototype"/>
其他的作用域选项
singleton 在每一个Spring容器中，一个Bean定义只有一个对象实例 默认
prototype 允许Bean被实例化任意次
request 在一次HTTP请求中，每个Bean定义对应一个实例 仅web有效
session 一个HTTP session中 每个Bean对应一个实例 仅web有效

Bean的初始化和销毁
使用 init-method和destroy method参数来配置<bean>元素
<bean id = "auditorium"
      class = "com.spring.springidol.Auditorium"
      init-method = "turnOnLights"
      destroy-method = "turnOffLights" />
另一种方案是实现InitializingBean和DisposableBean接口

注入Bean属性
简单的赋值 使用property标签
<bean id="kenny"
      class = "com.spring.springidol.Instrumentalist"
      <property name = "song" value = "Jingle Bells" />
</bean>

用其他Bean赋值 使用ref
<bean id="kenny2"
      class ="come.spring.springidol.Instrumentalist">
      <property name = "song" value ="Jingle Bells"
      <property name = "instrument" ref = "saxophone" />
</bean>
调用Bean
ApplicationContext ctx = new ClassPathXmlApplicationContext("com/spring/springidol/spring-idol.xml");
Performer performer = (Performer) ctx.getBean("kenny");
performer.perform();

注入内部Bean

<bean id="kenny"
      class = "com.spring.springidol.Instrumentalist">
      <property name = "song" value = "Jingle Bells" />
      <property name = "instrument">
        <bean class= "springinaction.springidol.Saxophone" />
      </property>
</bean>

装配集合

<list> 装配list类型的值
<set> 装配set类型的值 不允许重复
<map> 装配map类型的值 名称和值可以是任意类型
<props> 装配properties类型的值 名称和值都必须是String型

2.3 使用表达式装配
Spring Expression Language SpEL 一种强大简洁的装配方式

3.最小化Spring XML配置

自动装配 autowiring 减少<property> 元素和 <constructor-arg> 元素
自动检测 autodiscovery 更进一步自动识别哪些类需要配置为bean

4种类型的自动装配

byName 把与Bean属性具有相同名字(或id)的其他Bean自动装配到Bean对应的属性中
byType 把与Bean属性具有相同类型的其他Bean自动装配到该Bean的对应属性中
constructor 把与Bean的const 具体相同类型的其他Bean自动装配到Bean构造器对应args中
autodetect 首先尝试用const进行装配失败了尝试byType

3.2使用注解装配

Spring容器默认禁用注解装配 在使用基于注解的自动装配前 需要在Spring配置中启动它，
<context:annotation-config>

3种自动装配注解
1. @Autowired
2. @Inject
3. @Resource

1.@Autowired
可以对方法进行标注
@Autowired
public void setInstrcument(Instrument instrument){
	this.instrucment = instrucment
}
可以对构造器进行标注
@Autowired
public Instrumentalist(Instrument instrument){
	this.instrucment = instrucment
}
可以直接标注属性
@Autowired
private Instrument instrument;

可选的自动装配
1. 强契约，所标注的属性或者参数必须是可以装配的
2. Null 也可以接受 @Autowired(required = false)

多个Bean满足装配条件时，使用@Qualifier注解
@Autowired
@Qualifier("guitar")
private Instrument instrument;

还可以使用@Qualifier标注Guitar类
@Qualifier("stringed")
public class Guitar implements Instrument{
	...
}

创建自定义的限定器(Qualifier)

创建@Stringedinstrument注解来充当限定器

@Target({ElementType.FIELD, ElementType.PARAMETER, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Qualifier
public @interface StringInstrument{...}

可以用它来代替Qualifier

@StringedInstrument
public class Guitar implements Instrument{...}

2.@Inject
类似Autowired

3.注解中使用表达式
@Value("Eruption")
private String song;

@Value("#{SystemProperties.myFavoriteSong}")
private String song;

自动检测Bean
<context:component-scan> 允许Spring自动检测Bean和定义Bean

标注Bean
@Component 通用的构造型组件，标识为Spring组件
@Controller 标识为SpringMVC里的controller
@Repository 标识为数据仓库
@Service 标识该类为服务

过滤组件扫描
<context: include-filter> 的type和expression属性一起协作来定义组件扫描策略
过滤器类型
1.annotation 过滤器扫描使用指定注解所标注的类，通过expression属性指定要扫描的注解
2.assignable 过滤器扫描派生于expression属性所指定的类型的那些类
3.aspectj  过滤器扫描与expression属性所指定的AspectJ表达式所匹配的那些类
4.custom 自定义
5.regex 扫描正则表达式匹配的类

3.4 使用Spring基于Java的配置

定义一个配置类
在基于Java的配置里使用@Configuration注解的Java类就等价于XML配置中的<beans>元素

@Configuration
public class SpringIdolConfig{
  //Bean declaration methods go here
}

@Configuration注解作为一个标识告知Spring：这个类包含一个或多个Spring Bean的定义，这些Bean定义是使用@Bean注解所标注的方法

声明一个简单的Bean
使用@Bean注解标注一个方法来定义duke Bean

@Bean
public Performer duke(){
  return new Juggler();
}

使用Spring基于Java的配置进行注入

使用Spring基于Java编写一个返回类实例的方法 直接传值
为Bean装配另一个Bean的引用

@Bean
public Performer poeticDuke(){
  return new PoeticJuggler(sonnet29());
}
不会让方法产生新的实例

4. 面向切面的Spring
