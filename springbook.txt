I 第一部分 Spring的核心

Spring采用以下4种关键策略降低Java开发的复杂性：
1. 基于POJO的轻量级和最小入侵性编程
2. 通过依赖注入和面向接口实现松耦合
3. 基于切面和惯例进行声明式编程
4. 通过切面和模版减少样板代码

装配Bean
1. 创建Spring配置
 Spring是一个基于容器的框架，我们需要配置Spring来告诉它需要加载哪些Bean和如何装配这些Bean
 两种配置Bean的方式
 1.XML文件
 2.Java注解

Bean在XML中的位置
在XML文件中声明Bean，Spring配置文件的根元素是来源于Spring Bean命名空间所定义的<bean>元素：
<beans xmlns=""
      xmlns:xsi=""
      xsi:schemaLocation="">
      <!-- bean declarations go here -->
</beans>

Java自带多种XML命名空间，通过这些命名空间可以配置Spring容器
aop 声明切面以及将@AspectJ注解的类代理为Spring切面提供配置元素
beans 支持声明Bean和装配Bean
context 为配置Spring 应用上下文提供了配置元素，包括自动检测和自动装配Bean,注入非Spring直接管理的对象
jee 为声明消息驱动的POJO提供了配置元素
lang 配置由Groovy, JRuby, BeanShell等脚本实现的Bean
mvc 启动Spring MVC的能力 例如面向注解的控制器, 视图控制器，和拦截器
oxm 支持Spring对象到XML的映射配置
tx 提供声明式事物配置
util 工具类元素

声明一个Bean

<bean id="duke
      class="om.spring.springidol.Juggler" />

      <bean> 元素是Spring中最基本的配置单元，通过该元素Spring将创建一个对象。id属性定义了Bean的名字，也作为Bean在Spring容器中的引用.

通过构造器注入

1. 使用默认的构造器
2. 带一个int参数的构造方法

XML声明方式
<bean id="duke"
      class="com.spring.springidol.Juggler">
      <constructor-arg value= "15"/>
</bean>

扩展成一个PoeticJuggler
<bean id="duke"
      class="com.spring.springidol.Juggler">
      <constructor-arg value= "15"/>
      <constructor-arg ref="sonnet29" />
</bean>
逻辑类似于
Poem sonnet29 = new sonnet29();
Performer duke = new PoeticJuggler(15, sonnet29);

通过工厂方式创建Bean
Spring 支持通过<bean>元素的factory-method属性来装配工厂创建的Bean
<bean id= "theStage"
      class = "com.spring.springidol.Stage"
      factory_method = "getInstance" />

Bean的作用域
所有的Bean默认都是单列

如何让容器分配Bean时，每次请求都产生一个新的实例？
只需要配置Bean的scope属性为prototype即可
<bean id="ticket"
      class="com.spring.springidol.Ticket" scope = "prototype"/>
其他的作用域选项
singleton 在每一个Spring容器中，一个Bean定义只有一个对象实例 默认
prototype 允许Bean被实例化任意次
request 在一次HTTP请求中，每个Bean定义对应一个实例 仅web有效
session 一个HTTP session中 每个Bean对应一个实例 仅web有效

Bean的初始化和销毁
使用 init-method和destroy method参数来配置<bean>元素
<bean id = "auditorium"
      class = "com.spring.springidol.Auditorium"
      init-method = "turnOnLights"
      destroy-method = "turnOffLights" />
另一种方案是实现InitializingBean和DisposableBean接口

注入Bean属性
简单的赋值 使用property标签
<bean id="kenny"
      class = "com.spring.springidol.Instrumentalist"
      <property name = "song" value = "Jingle Bells" />
</bean>

用其他Bean赋值 使用ref
<bean id="kenny2"
      class ="come.spring.springidol.Instrumentalist">
      <property name = "song" value ="Jingle Bells"
      <property name = "instrument" ref = "saxophone" />
</bean>
调用Bean
ApplicationContext ctx = new ClassPathXmlApplicationContext("com/spring/springidol/spring-idol.xml");
Performer performer = (Performer) ctx.getBean("kenny");
performer.perform();

注入内部Bean

<bean id="kenny"
      class = "com.spring.springidol.Instrumentalist">
      <property name = "song" value = "Jingle Bells" />
      <property name = "instrument">
        <bean class= "springinaction.springidol.Saxophone" />
      </property>
</bean>

装配集合

<list> 装配list类型的值
<set> 装配set类型的值 不允许重复
<map> 装配map类型的值 名称和值可以是任意类型
<props> 装配properties类型的值 名称和值都必须是String型

2.3 使用表达式装配
Spring Expression Language SpEL 一种强大简洁的装配方式

3.最小化Spring XML配置

自动装配 autowiring 减少<property> 元素和 <constructor-arg> 元素
自动检测 autodiscovery 更进一步自动识别哪些类需要配置为bean

4种类型的自动装配

byName 把与Bean属性具有相同名字(或id)的其他Bean自动装配到Bean对应的属性中
byType 把与Bean属性具有相同类型的其他Bean自动装配到该Bean的对应属性中
constructor 把与Bean的const 具体相同类型的其他Bean自动装配到Bean构造器对应args中
autodetect 首先尝试用const进行装配失败了尝试byType

3.2使用注解装配

Spring容器默认禁用注解装配 在使用基于注解的自动装配前 需要在Spring配置中启动它，
<context:annotation-config>

3种自动装配注解
1. @Autowired
2. @Inject
3. @Resource

1.@Autowired
可以对方法进行标注
@Autowired
public void setInstrcument(Instrument instrument){
	this.instrucment = instrucment
}
可以对构造器进行标注
@Autowired
public Instrumentalist(Instrument instrument){
	this.instrucment = instrucment
}
可以直接标注属性
@Autowired
private Instrument instrument;

可选的自动装配
1. 强契约，所标注的属性或者参数必须是可以装配的
2. Null 也可以接受 @Autowired(required = false)

多个Bean满足装配条件时，使用@Qualifier注解
@Autowired
@Qualifier("guitar")
private Instrument instrument;

还可以使用@Qualifier标注Guitar类
@Qualifier("stringed")
public class Guitar implements Instrument{
	...
}

创建自定义的限定器(Qualifier)

创建@Stringedinstrument注解来充当限定器

@Target({ElementType.FIELD, ElementType.PARAMETER, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Qualifier
public @interface StringInstrument{...}

可以用它来代替Qualifier

@StringedInstrument
public class Guitar implements Instrument{...}

2.@Inject
类似Autowired

3.注解中使用表达式
@Value("Eruption")
private String song;

@Value("#{SystemProperties.myFavoriteSong}")
private String song;

自动检测Bean
<context:component-scan> 允许Spring自动检测Bean和定义Bean

标注Bean
@Component 通用的构造型组件，标识为Spring组件
@Controller 标识为SpringMVC里的controller
@Repository 标识为数据仓库
@Service 标识该类为服务

过滤组件扫描
<context: include-filter> 的type和expression属性一起协作来定义组件扫描策略
过滤器类型
1.annotation 过滤器扫描使用指定注解所标注的类，通过expression属性指定要扫描的注解
2.assignable 过滤器扫描派生于expression属性所指定的类型的那些类
3.aspectj  过滤器扫描与expression属性所指定的AspectJ表达式所匹配的那些类
4.custom 自定义
5.regex 扫描正则表达式匹配的类

3.4 使用Spring基于Java的配置
在基于Java配置里使用@Configuration注解的Java类，就等价于XML配置中的<bean>元素

定义一个配置类
在基于Java的配置里使用@Configuration注解的Java类就等价于XML配置中的<beans>元素

@Configuration
public class SpringIdolConfig{
  //Bean declaration methods go here
}

@Configuration注解作为一个标识告知Spring：这个类包含一个或多个Spring Bean的定义，这些Bean定义是使用@Bean注解所标注的方法

声明一个简单的Bean
使用@Bean注解标注一个方法来定义duke Bean

@Bean
public Performer duke(){
  return new Juggler();
}

使用Spring基于Java的配置进行注入

使用Spring基于Java编写一个返回类实例的方法 直接传值
为Bean装配另一个Bean的引用

@Bean
public Performer poeticDuke(){
  return new PoeticJuggler(sonnet29());
}
不会让方法产生新的实例

4. 面向切面的Spring

通知（Advice)
5种类型
Before 在方法被调用之前调用通知
After 在方法完成后调用通知, 无论方法执行成功与否
After-returning 在方法成功执行之后调用通知
After-throwing 在方法抛出异常之后调用通知
Around 通知包裹了被通知的方法，在被通知的方法调用之前和调用之后 执行自定义的行为

连接点（JoinPoint)
连接点是在应用执行的过程中能够插入切面的一个点，这个点可以是调用方法，抛出异常，修改字段时，切面代码可以利用这些点插入到应用的正常流程之中，
并添加新的行为

切点（Pointcut)
切点的定义会匹配通知所要织入的一个或多个连接点，通常使用明确的类和方法名称来指定这些切点，或者是利用正则表达式定义匹配的类和方法名称

切面 （Aspect）
切面是通知和切点的结合

引入（Introduction）
引入允许我们向现有的类添加新的方法和属性

织入（Weaving）
织入是将切面应用到目标对象来创建新的代理对象的过程。切面在指定的连接点被织入到目标对象中，在目标对象的生命周期里有多个点可以进行织入。

编译期-切面在目标类编译时被织入,比如ApsectJ织入编译器

类加载器-切面在目标类加载到JVM时被织入

运行期-切面在应用运行的某个时刻被织入，在织入切面时，AOP容器会为目标对象动态的创建一个代理对象。Spring AOP

Spring提供4种AOP支持
1.基于代理的经典AOP 只支持方法连接点
2.@AspectJ注解驱动的切面
3.纯POJO切面
4注入式AspectJ切面

1.经典AOP
代理类封装了目标类，并拦截被通知的方法的调用，再将调用转发给真正的目标Bean

2.AspectJ
Spring仅支持AspectJ切点指示器的一个子集，Spring是基于代理的，而某些切点表达式是与基于代理的AOP无关的
Spring AOP所支持的AspectJ切点指示器

arg() 指定类型的方法
@args() 指定注解标注的执行方法
execution() 用于匹配是连接点的执行方法
this() 限制连接点匹配AOP代理的Bean引用为指定类型的类
target() 匹配目标对象为指定类型的类
@target() 匹配特定的执行对象，对象对应的类要具备指定类型的注解
within() 匹配指定的类型
@within() 匹配注解所标注的类型
@annotation 匹配带有指定注解的连接点

编写切点

execution(*com.spring.springidol.Instrument.play(..))

execution() 方法返回时候触发（连接点的执行方法）
* 返回任意类型
com.spring.springidol.Instrument 方法所属的类
.play 此方法
(..) 参数匹配

如果仅仅匹配com.spring.springidol包
可以用within()指示器来限制匹配
execution(*com.spring.springidol.Instrument.play(..)) && within(com.spring.springidol.*)

&& || !都可以适用

bean()指示器
允许我们在切点表达式中使用Bean的ID来标识Bean bean使用 BeanID或Bean名称作为参数来限制切点只匹配特定的Bean

在执行Instrument的play() 方法时应用通知，但限定Bean的ID为eddie

execution(* com.spring.springidol.Instrument.play()) and bean(eddie)

声明环绕通知
如果不使用成员变量储存信息，那么在前置通知和后置通知之间共享信息非常麻烦,因为Audience是单例，如果像这样保存状态，它将存在现成安全问题
为了避免使用成员变量中保存开始时间，使用环绕通知在这点上有明显优势, 在一个方法内实现前置通知和后置通知所实现的相同功能，不需要使用成员变量。


public void watchPerformance(ProceedingJoinPoint JoinPoint){
long start = System.currentTimeMillis();  <- 之前
joinPoint.proceed();                      <- 执行方法
long end = System.currentTimeMillis();    <- 之后
}

ProceedingJoinPoint 能让我在通知里调用被通知方法
通知方法可以完成任何它所需要做的事情，而且如果希望把控制转给被通知的方法时, 我们可以调用ProceedingJoinPoint的proceed()方法

用于解决跨服务调用超时问题: 
hystrix:
  metrics:
    enabled: true
  command:
    default:
      execution:
        timeout:
          enabled: false

3. AOP 配置元素                                       描述
<aop: advsior>                  定义AOP通知器
<aop: after>                    定义AOP后置通知
<aop: after-returning>          定义AOP after-returning 通知
<aop: after-throwing> 			定义 after-throwing 通知
<aop: around>                   定义AOP环绕通知
<aop: aspect> 					定义切面
<aop: aspect-autoproxy> 		启动@AspectJ注解驱动的切面
<aop: before> 					定义 AOP前置通知
<aop: config> 					顶层的AOP配置元素, 大多的<aop:*> 元素必须包含在<aop:config> 元素内
<aop: declare-parents> 			为被通知的对象引入额外的接口，并透明的实现
<aop: pointcut> 				定义切点


前置声明和后置通知

<aop:config>
	<aop:aspect ref = "audience"> 
		<aop:before pointcut = "execution(* com.springinaction.springidol.Performer.perform(..))*"
			method="takeSeats" />
		<aop:after-returning pointcut= "execution(* com.springinaction.springidol.Performer.perform(..))"
			method="applaud" />
		<aop:after-throwing pointcut= "execution (* com.springinaction.springidol.Performer.perform(..))"
			method="demandRefund" />
	</aop: aspect> 
</aop:config> 	

为了避免重复定义切点，使用<aop: pointcut>元素定义一个命名切点
<aop:pointcut id="performance" expression= "*execution(*com.springinaction.springidol.Performer.perform(..))" />
引用该切点
<aop:before pointcut-ref="performance" method="takeSeats" />

4.4注解切面

@AspectJ进行标注

@Pointcut注解用于定义一个可以在@AspectJ切面内可重用的切点，注解的值是一个切点表达式

因为Audience类本身包含了所有它所需要定义的切点和通知，所以我们不需要在XML中配置声明的切点和通知。最后一件需要做的事是让Spring将
Audience应用为一个切面。我们需要在Spring上下文中声明一个自动代理Bean,该Bean如何把@AspectJ注解所标注的Bean转变为代理通知
为此Spring自带了名为AnnotationAwareAspectJAutoProxyCreator的自动代理创建类。我们需要在Spring上下文中把AnnotationAwareAspectJ
toProxyCreator注册为一个bean, 简化这样的操作，我们在aop命名空间中提供了<aop:aspectj-autoproxy/>，在Spring上下文中创建一个类，
它会自动代理一些bean. 

<aop:aspect> 相比于@AspectJ的优势是不需要源码

注解环绕通知 @Around 需要一个ProceedingJointPoint对象 作为方法入参，并在对象上调用proceed()方法

传递参数给所标注的通知
@Pointcut ("execution (* com.springinaction.springidol. ") + "Thinker.thinkOfSomething(String")) && args(thoughts)*)
public void thinking(String thoughts){}

@Before("thinking(thoughts")*)
public void interceptThoughts(String thoughts){
	System.out.println("Intercepting volunteer's thoughts: "+ thoughts);
	this.thoughts = thoughts;
} 

@DeclareParents 等价于 <aop:declare-parents> 

@AspectJ
public class ContestantIntroducer{

-----------引入Contestant接口-------------------
@DeclareParents(
value = "com.springinaction.springidol.Performer+". 
defaultImpl = "GraciousContestant.class"
)

public static Contestant contestant;
}

Contestant 为Performer Bean 引入了Contestant接口
@DeclareParents 注解3部分组成
value 属性等同于<aop:declare-parents>的types-matching属性，它标识应该被引入指定接口的Bean类型
defaultImpl属性等同于<aop:declare-parents>的default-impl属性。它标识该类提供所引入接口的实现
由@DeclareParents 注解所标注的static属性指定了将被引入的接口

4.5注入AspectJ切面

使用Spring 依赖注入把Bean装配进AspectJ切面中
public aspect JudgeAspect{
	public JudgeAspect(){}
	pointcut performance() : execution (* perform(..)); 
	after() returning() : performance(){
		System.out.println(criticismEngine.getCritism());
	}

	//injected
	private CriticismEngine criticismEngine;
	public void setCriticismEngine(CriticismEngine criticismEngine){
		this.criticismEngine = criticismEngine; 
	} 
}

JudgeAspect的主要职责是在表演之后为表演发表评论
JudgeAspect与一个CritismEngine对象协作，在表演结束时候，调用该对象的getCriticism()方法来发表一个评论
为了避免JudgeAspect和CritismEngine之间产生不必要的耦合，通过setter依赖注入为JudgeAspect赋予CriticismEngine

如下关系： 
			通知                 getCritism()
Performer  <------  JudgeAspect --------------> CritismEngine
						   ^					     ^
							\						 |					
							 \	注入进去				 |
							  \						 |
							   \				     |
								\ 			         |

								  CriticismEngineImple


切面也需要注入，如果AspectJ切面需要其他Bean, Spring也可以为AspectJ切面注入依赖

AspectJ切面不需要Spring就可以织入我们的应用中，但是如果想使用Spring的依赖注入为AspectJ切面注入协作者，那么就需要在Spring
配置中把切面声明为一个SpringBean. 如下的<bean> 声明会把criticismEngine bean注入到JudgeAspect中

<bean class = "com.sprininaction.springidol.JudgeAspect" factory-method = "aspectOf"
		<property name="criticismEngine" ref ="criticismEngine" /> 
</bean> 

通常情况下Spring Bean由Spring容器初始化, 但是AspectJ切面是由AspectJ在运行期创建的。等到Spring有机会为JudgeAspect注入
CriticismEngine时，JudgeAspect已经被实例化了。我们需要一种方式为Spring获得已经由AspectJ创建的JudgeAspect实例的句柄,从
而可以注入CriticismEngine. AspectJ提供了一个静态的aspectOf()方法, 该方法返回切面的一个单例. 

JudgeAspect装配CriticismEngineImpl，使用Spring注入为AspectJ切面注入协作者，那么就需要在Spring配置中把切面声明为一个Spring Bean
如下的<bean>声明会把criticismEngine Bean注入到Judge Aspect中

<bean class = "com.springinaction.springidol.JudgeAspect" factory-method= "aspectOf"
	<property name= " criticismEngine" ref = "criticismEngine" /> 
</bean>

简而言之，Spring不能使用<bean>声明来创建一个JudgeAspect实例-它已经在运行时候由AspectJ创建了。Spring通过aspectOf()工厂方法获得切面
的引用, 然后像<bean> 元素规定的那样在该对象上执行依赖注入

II Spring应用程序的核心组件

5.1 Spring的数据访问哲学

服务对象  ------> DAO接口 
				    ^
				    |
				    |
				    |
				    |
				 DAO实现

服务对象本身并不会处理数据访问, 而是将数据访问委托给DAO, DAO接口确保其与服务对象的松耦合。

好处  1.服务对象易于测试, 因为它们不再于特定的数据访问实现绑定在一起。
	  2.数据访问是以持久化技术无关的方式来进行访问的，持久化的选择独立于DAO, 只有相关的数据访问方法通过接口来进行发布.

了解Spring数据访问异常体系
Spring异常体系优于JDBC，几乎为读取和写入数据库所有错误都提供了异常，并不与特定的持久化方式相关联，意味着我们可以使用Spring
抛出一致的异常，而不用关系所选用的持久化方案。这有助于我们将所选择的持久化机制与数据访问层隔离开来。

JBDC异常                                                          Spring的数据访问异常

BatchUpdateException											CannotAcquireLockException
DataTruncation													CannotSerializeTransactionException
SQLException													CleanupFailureException
SQLWarning														ConcurrencyFailureException
																DataAccessException	
																DataAccessResourceFailureException
																DataIntegrityViolationException
																DataRetrieveFailureException
																DeadlockLoserDataAccessException
																EmptyResultDataAccessException
																IncorrectResultSizeDataAccessException
																IncorrectUpdateSemanticsDataAccessException
																InvalidDataAccessApiUsageException
																InvalidDataAccessResourceUsageException
																OptimisticLockingFailureException
																PermissionDeniedDataAccessException
																PessimisticLockingFailureException
																TypeMismatchDataAccessException
																UncategorizedDataAccessException

5.1.2 数据访问模板化

Spring将数据访问过程中固定的和可变的部分划分为:模板template和回调callback
Spring的模板类处理数据访问的固定部分-事务控制，管理资源及处理异常。应用程序相关的数据访问，在回调的实现中处理。

Spring的DAO模板类负责通用的数据访问功能，对于应用程序特定的任务，则会回调自定义的DAO回调对象

Spring的DAO模板负责通用的数据访问功能。对于应用程序的特定任务，则会调用自定义的DAO回调对象

1.准备资源 2.开始事务 3.在事务中执行 4. 返回数据 5提交/回滚事务 6.关闭资源和处理错误

针对不同的持久化平台, Spring提供了多个可选的模板。如果直接使用JDBC, 则可选择JDBC template, 如果希望使用对象关系映射框架
则用hibernate-template或JpaTemplate

模板类(org.springframework.*)                                   用途
jca.cci.core.CciTemplate                                       JCA CCI连接
jdbc.core.JdbcTemplate                                         JDBC连接
jdbc.core.namedparam.NamedParameterJdbcTemplate 			   命名参数的JDBC连接
jdbc.core.simple.SimpleJdbcTemplate							   Java5简化后的JDBC连接
orm.hibernate.HibernateTemplate								   Hibernate2.x的Session
orm.hibernate3.HibernateTemplate							   Hibernate3.x的Session
orm.ibatis.SqlMapClientTemplate								   iBATIS SqlMap客户端
orm.jdo.JdoTemplate											   Java数据对象(Java Data Object)的实现
orm.jpa.Template  											   Java持久化API的实体管理器


5.1.3 使用DAO支持类
基于模板-回调设计，Spring提供了DAO支持类，而将业务自己的DAO类作为它的子类

应用程序DAO -> DAO支持类 -> 数据访问模板 -> 持久化框架 -> 数据库

SpringDAO支持类提供了便携的方式来使用数据访问模板

DAO支持类 														为谁提供DAO支持
jca.cci.support.CciDaoSupport 								 	JCA CCI连接
jdbc.core.support.JdbcDaoSupport								JDBC 连接
jdbc.core.namedparam.NamedParameterJdbcDaoSupport				命名参数的JDBC连接
jdbc.core.simple.SimpleJdbcDaoSupport							Java5简化后的JDBC连接
orm.hibernate.support.HibernateDaoSupport						Hibernate2.x的Session
orm.hibernate3.support.HibernateDaoSupport						Hibernate3.x的Session
orm.ibatis.support.SqlMapClientDaoSupport						iBATIS SqlMap客户端
orm.jdo.support.JdoDaoSupport									Java数据对象(Java Data Object)的实现
orm.jpa.support.JpaDaoSupport									Java持久化API的实体管理器

5.2 配置数据源
不管选择哪一种Spring Dao的支持方式, 你可能都需要配置一个数据源的引用. Spring提供了在Spring上下文中配置数据源Bean
的多种方式, 包括： 
1. 通过JDBC驱动程序定义的数据源
2. 通过JNDI查找的数据源
3. 连接池的数据源

5.2.1使用JNDI数据源

Spring应用程序经常部署在Java EE应用服务器中, 如WebSphere, JBoss或者像Tomcat这样Web容器
利用Spring，我们可以像使用Spring Bean那样配置JNDI中数据源的引用并将其装配到需要的类中.
<jee:jndi-lookup id="dataSource" 
	jndi-name="/jdbc/SpitterDS"
	resources-ref="true" />

jndi-name用于指定JNDI资源中的名称，如果只设置了jndi-name属性，那么就会根据指定的名称查找数据源，
如果应用程序运行在java程序服务器中，则需要将resource-ref属性设置为true

5.2.2 使用数据源连接池

如果你不能从JNDI中查找数据源, 那么下一个选择就是直接在Spring中配置数据源连接池. DBCP包含了多个提供连接池功能的数据源
,其中BasicDataSource	是最常用的


BasicDataSource的池配置属性								所指定的内容	  					
initalSize												池启动时创建的连接数量
maxActive												同一时间可从池中分配的最多连接数，如果设置为0，表示无限制
maxIdle													池里不会被释放的最多空间连接数，如果设置为0，表示无限制 
maxOpenPreparedStatements								在同一时间能够从语句池中分配的预处理语句最大数量，如果设置为0，表示无限制 			
maxWait													在抛出异常前，池等待连接回收的最大时间,设置-1表示无限等待						
minEvictableTimeMillis									连接池中保持空闲而不被收回的最大时间			
minIdle													在不创建新连接的情况下，池中保持空闲的最小连接数 
poolPreparedStatements									是否对预处理语句进行池管理(boolean)

JDBC驱动的数据源

通过JDBC定义驱动是最简单的方式, Spring提供了两种数据源对象供选择
DriverManagerDataSource: 在每个连接请求时，都会返回一个新建的连接，不进行池化管理
SingleConnectionDataSource: 在每个连接请求时都会返回同一个连接。尽管SingleConnectionDataSource不是严格 意义上的连接池数据源,
但是可以视为只有一个连接的池

SingleConnectionDataSource不适用于多线程的应用程序，DriverManagerDataSource支持多线程，但是在每次请求连接时候都会创建新连接
以性能为代价，所以强烈建议使用数据源连接池

5.4在Spring中集成Hibernate

延迟加载(Lazy load)
借助延迟加载，我们可以只抓取需要的数据

预先抓取(Eager fetching)
借助预先抓取，我们可以使用一个查询获取完整的关联对象，预先抓取的功能可以在一个操作中将他们全部从数据库中提取出来，节省了多次查询的成本

级联(Cascading)
有时，更改数据库同时会修改其他表，我们希望一次操作能将关联的表多表修改

ORM(object-relational mapping)
Spring对ORM框架的支持提供了这些框架的集成点以及一些附加的服务
*Spring声明式事务的集成支持
*透明的异常处理
*线程安全，轻量级模板类 
*DAO支持类
*资源管理

5.4.1 Hibernate概览

在Spring应用程序中使用Hibernate是通过HibernateTemplate进行的，HibernateTemplate简化了使用Hibernate的繁琐工作，
并且是通过捕获Hibernate特定的异常，然后转换成Spring的非检查型数据库访问异常并重新抛出而实现的

HibernateTemplate职责之一是管理Hibernate的Session，这涉及打开和关闭Session并确保每个事务使用相同的Session，如果
没有HibernateTemplate, 我们只能让自己的DAO充满了Session管理的样板代码

HibernateTemplate的不足之处在于存在一定程度的入侵性. 当我们在DAO中使用HibernateTemplate时，DAO类就会与Spring API
产生耦合

Hibernate3引入上下文Session(Contextual Session)，这是Hibernate本身所提供的保证每个事务使用同一Session的方案，因此
没有必要使用HibernateTemplate保证这一行为了。在使用Hibernate Contextual Session之前，我们需要为Hibernate做一些准备
工作即在Spring里配置Session Factory

5.4.2 声明Hibernate的Session工厂

使用Hibernate的主要接口时org.hibernate.Session. Session接口提供了基本数据访问功能，CRUD以及从数据库加载对象功能.
标准方式是借助于Hibernate的SessionFactory接口实现类。除了一些其他的任务，SessionFactory主要负责Hibernate Session
的打开，关闭以及管理.

在Spring中，我们要通过Spring的某一个Hibernate Session工厂Bean来获取Hibernate的SessionFactory.我们可以在应用程序
的Spring上下文中，像配置其他Bean那样来配置Hibernate Session工厂

在配置Hibernate Session工厂Bean的时候，我们需要确定持久化域名对象是通过XML文件还是通过注解来进行配置的, 如果你更倾向
用注解的方式来定义持久化，那需要使用AnnotationSessionFactoryBean来替代LocalSessionFactoryBean

dataSource声明从哪里获得数据库连接
hibernateProperties声明了要使用哪一种数据库
packagesToScan属性告诉Spring扫描一个或多个包以查找域类，这些类通过注解方式表明要使用Hibernate进行持久化。
JPA的@Entity 或者 @MapperSuperClass 注解以及Hibernate的@Entity 注解进行标注的类都会包含在内

anntotatedClasses属性将应用程序所以持久化类以全限定名的方式明确列出，annototatedClasses属性对于准确指定少量的域类是
不错的选择。如果你有很多的域类且不想将其全部列出，或者你想自由的添加移除域类而不想修改Spring配置的话,则使用packageToScan
更合适

5.4.3 构建不依赖于Spring的Hibernate 代码

在没有上下文时候，Spring的Hibernate模板用于保证每个事务使用同一个Session. 既然Hibernate自己能够对其进行管理, 那就没有
必要使用模板类了。意味着能直接将Hibernate装配到DAO中

@Repository
public class HibernateSpitterDao implements SpitterDao{
	private SessionFactory sessionFactory;

	@Autowired
	public HibernateSpitterDao(SessionFactory sessionFactory){
		this.sessionFactory = sessionFactory;                     <------ 构造DAO
	}

	private Session currentSession(){
		return sessionFactory.getCurrentSession();            <----- 从SessionFactory中获取当前Session
	}

	private void addSpitter(Spitter spitter){					<------ 使用当前的Session
		currentSession().save(spitter);                      
	}

	public Spitter getSpitterById(long id){
		return (Spliter) currentSession().get(Spitter.class, id);           <------ 使用当前的Session
	}

	public void saveSpitter(Spitter spitter){
		currentSession.update(spitter);
	}
}

@Autowired 注解可以让Spring自动将一个SessionFactory注入到HibernateSpitterDao的sessionFactory属性中
接下来在currentSession()方法中，使用这个SessionFactory来获取当前事务的Session.

@Repository 注解能够像其他注解一样被<context:component-scan>所扫描到, 这样不必明确声明HibernateSpitterDao
Bean了.
不适用模板的Hibernate DAO添加异常转换功能,我们只需在Spring应用上下文中添加一个PersistenceExceptionTranslation
PostProcessor Bean.

PersistenceExceptionTranslationPostProcessor是一个Bean的后置处理程序, 它会在所有拥有@Respository注解的类上
添加一个通知器advsior, 这样就能捕获任何平台相关的异常并以Spring 非检查型数据访问异常的形式抛出

5.5 Spring 与Java 持久化 API

5.5.1 配置实体管理工厂
基于JPA的应用程序 使用EntityManagerFactory的实现类来获取EntityManager实例 JPA定义了两种类型的实体管理器

应用程序类管理器 Application-managed: 当应用程序向实体管理器工厂直接请求实体管理器时，工厂会创建一个实体管理器。
在这种模式下，程序要负责打开或关闭实体管理器并在事务中对其进行控制。 这种方法的实体管理器适合不运行在Java EE容器中
独立的应用程序

容器管理器 Container-managed: 实体管理器是由Java EE创建和管理. 应用程序根本不与实体管理器工厂打交道. 相反，实体管理器
直接通过注入或者JNDI来获取。容器负责配置实体管理器工厂。这种类型的实体管理器最适合用于Java EE的容器。

以上两种实体管理器实现了同一个EntityManager接口。关键区别不在于EntityManager本身，而是在于EntityManager的创建和管理方式
应用程序管理类型的EntityManager是由EntityManagerFactory所创建的，而后者是通过PersistenceProvider的createEntityManager
Factory()方法得到的

这两种实体管理器工厂分别由对应的Spring工厂Bean创建

LocalEntityManagerFactoryBean 生成应用程序管理类型的EntityManagerFactory
LocalContainerEntityManagerFactoryBean 生成容器管理类型的EntityManagerFactory

使用应用程序管理类型的JPA
使用容器管理类型的JPA

5.5.2 编写基于JPA的DAO

正如Spring对其他持久化方案的集成，Spring对JPA的集成也提供了JpaTemplate模板以及对应的支持类JpaDaoSupport
不使用Spring JpaTemplate的DAO

@Repository(*spitterDao*)
@Transactional
public class JpaSpitterDao implements SpitterDao {
	private static final String RECENT_SPITTERS = *SELECT s FROM Spittle s*;
	private static final String ALL_SPITTERS = *SELECT s FROM Spittle s WHERE s.username = :username*;

	@PersistenceContext
	private EntityManager em;                   <------ 注入EntityManager

	public void addSpitter(Spitter spitter){
		em.persist(spitter);                    <------使用EntityManager   
	}

	public Spitter getSpitterById(long id){
		return em.find(Spitter.class, id);       <------使用EntityManager   
	}
}

JpaSpitterDao使用了EntityManager处理持久化。通过使用EntityManager, Dao非常干净并且干起来就像没有使用Spring的
DAO, em使用了@PersistentContext 注解，表明需要在Spring应用上下文配置一个PersistenceAnnotationBeanPostProcessor

6 事务管理

ACID 
原子性 Atomic 事务是由一个或多个活动组成的一个工作单元，原子性确保事务中所有操作全部发生或者全部不发生
一致性 Consistenct 一旦事务完成，系统必须确保它所建模的业务处于一致的状态。现实的数据不应该被破坏
隔离性 Isolated 事务允许多个用户对相同的数据进行操作，每个用户的操作不会与其他用户纠缠在一起
持久性 Durable 一旦事务完成，事务的结果应该持久化，这样就能从任何崩溃的系统中恢复过来

6.2 选择事务管理器

Spring并不直接管理事务，而是提供了多种事务管理器，它们将事务管理的职责委托给JTA或其他持久化机制所提供的平台
相关的事务实现

事务管理器(org.framework.*)								使用场景
jca.cci.connection.CciLocalTransactionManager		使用Spring 对JavaEE连接器架构和通用客户端接口提供支持
jdbc.datasource.DataSourceTransactionManager 	用于Spring对JDBC抽象的支持也可也用于使用iBatis进行持久化的场景                        
jms.connection.JmsTransactionManager 			用于JMS1.1+
jms.connection.JmsTranscationManager102			用于JMS1.0.2
orm.hibernate3.HibernateTranscationManager		用于Hibernate3进行持久化
orm.jdo.JdoTransactionManager 					用于JDO进行持久化
orm.jpa.JpaTransactionMagaer 					用于Java持久化API
transaction.jta.JtaTransactionManager			需要分布式事务或者没有其他的事务管理器满足需求
transaction.jta.OC4JJtaTransactionManager		用于Oracle的OC4J JEE容器
transaction.jta.WebLogicJtaTransactionManager	需要分布式事务并且程序应用于WebLogic中
transaction.jta.WebSphereUowTranscationManager	需要WebSphere中UOWManager所管理的事务

JDBC事务
如果在应用程序中直接使用JDBC来进行持久化 DataSourceTransactionManager会为你处理事务边界，要注意的是dataScource属性值
配置成了一个名为dataSource bean的引用。而dataSource是定义在上下文文件中javax.sql.DataSource Bean.

Hibernate事务
如果应用程序通过Hibernate实现的，那么你需要使用HibernateTranscationManager。 sessionFactory属性需要装配一个Hibernate 
SessionFactory

JPA事务
如果使用JPA, 使用Spring中的JpaTranscationManager来处理事务, JpaTransactionManager只需要装配一个JPA实体管理工厂.
JPATransactionManager将于工厂产生的JPA EntityManager合作来构建事务
除了将事务应用于JPA操作，JpaTranscationManager还支持将事务应用于简单的JDBC操作中,这些JDBC操作所使用的DataSource与
EntityManagerFactory所使用的DataSource必须是相同的。为了做到这一点，JpaTransactionManager必须装配一个JpaDialect的
实现，然后你还需要将jpaDialect Bean装配到JpaTransactionManager中

添加事务的一种方式是在saveSpittle()方法中直接通过编码使用Spring的TransactionTemplate来添加事务性边界。

public void saveSpittle(final Spittle spittle){
	txTemplate.execute(new TransactionCallback<Void>(){
		public void doInTransaction(TranscationStatus txStatus){
			try{
				spitterDao.saveSpittle(spittle);
			}catch(RuntimeException e){
				txStatus.setRollbackOnly();
				throw e;
			}
			return null;
		}
	})
}

为了使用TranscationTemplate, 你需要实现TransactionCallback接口，因为TransactionCallback只有一个要实现的方法，通常使用内部
匿名类，放在doInTranscation()中.

调用TransactionTemplate实例的execute方法时, 将会执行TransactionCallback实例中的代码.如果代码遇到问题，调用TranscationStatus
对象的setRollbackOnly()方法将回滚事务，否则如果doInTransaction()成功返回, 事务将会成功提交.

6.4.1定义事务属性

声明式事务是通过事务属性来定义的

1. 传播行为(propagation behavior)								

定义了何时要创建一个事务或者何时使用已有的事务

传播行为														含义

PROPAGAGTION_MANDATORY 				表示该方法必须在事务中运行，当前事务不存在，则抛出异常
PROPAGAGTION_NESTED					存在一个事务，改方法会在嵌套事务中运行，嵌套事务可以独立于当前事务进行回滚，如果当前事务不存在
									则行为与PROPAGATION_REQUIRED一样
PROPAGATION_NEVER					表示当前方法不应该运行在事务上下文当中，如果当前正有事务在运行，抛出异常
PROPAGATION_NOT_SUPPORT				表示方法不应该运行在事务中，如果在当前事务，该方法运行期间，事务将会被挂起
PROPAGATION_REQUIRED 				表示方法必须允许与事务中，当前事务存在，则运行于当前事务，否则另起一个新事务
PROPAGATION_REQUIRED_NEW			表示当前方法必须运行在它自己的事务中，一个新的事务将被启动，如果存在当前事务，
									则在该方法执行期间，事务会被挂起
PROPAGATION_SUPPORTS 				表示当前方法不需要事务上下文，但是如果存在当前事务的话，那么该方法会在这个事务中运行

2. 隔离级别 

定义了一个事务可能受其他并发事务影响的程度

脏读 Dirty Reads
脏读发生在一个事务读取了另一个事务改写但尚未提交数据时候,如果改写在稍后被回滚了，那么第一个事务获取的数据就是无效的

不可重复读 Nonrepeatable read 
发生在一个事务执行查询两次或者两次以上，但是每次都得到不同的数据，通常因为另一个并发事件在两次查询期间更新了数据

幻读 Phantom read
一个事务读取了几行数据，接着另一个并发事务插入了一些数据时，在随后的查询中第一个事务就会发现多了一些原本不存在的事务

隔离级别														含义
ISOLATION_DEFAULT										默认隔离级别
ISOLATION_READ_UNCOMMITTED								允许读取尚未提交的数据变更，可能会导致脏读，幻读，不可重复读
ISOLATION_READ_COMMITTED								允许读取并发事务以及提交的数据，可以阻止脏读，但是会有幻读和不可重复读
ISOLATION_REPEATABLE_READ								对同一字段的多次读取结果一致的，除非数据是被本事务所修改，
														可以阻止脏读和不可重复读, 但是仍有可能发生幻读
ISOLATION_SERILAIZABLE									完全服从ACID的隔离级别

3. 只读

4. 事务超时 

5.回滚原则

事务五边形5各方面通过该元素属性来指定

属性 														含义
isolation 												指定事务的隔离级别
propagation 											定义事务的传播规则
read-only												只读
rollback-for/no-rollback-for							回滚原则
timeout													超时

定义注解驱动事务

@Transactional(propagation = Propagation.SUPPORTS, readOnly= true)

7 Spring MVC

7.1.1 跟踪Spring MVC的请求

SpringMVC的核心是DispatcherServerlet, 这个Servlet充当SpringMVC的前端控制器

<servelet-name> DispatchServerlet加载时会从一个基于这个Serverlet名字的XML文件中加载Spring应用上下文
必须声明DispatchServerlet处理哪些URL，比较常见DispatchServerlet匹配模式是*.htm, /*, 或者/app 

*htm 隐式表明响应始终是HTML格式的
/*将其匹配的话没有映射特定的响应，它表明DispatcherServelet将处理所有的请求
/app模式 帮助我们区分了DispatcherServerlet处理的内容和其他内容，但这样就会在URL中暴露了实现的细节

建议使用/模式

编写基本的控制器

Web浏览器                  其他客户端
	\                         /
	 \                       / 
	  \						/
	   \				   /	
	   	  Web (controller)
	   	  		|	
	   	  		|
	   	  		|
	   	  		|
			 Service     --------- Domain
				|
				|
				|
				|
			Persistence		
				|
				|
				|
				|
			Data Store
			
7.2.1 配置注解驱动的Spring MVC 
DispatchServerlet需要咨询一个或者多个处理器映射来明确将请求分发给哪个控制器

Spring 自带了多个处理器映射供我们选择如下: 

BeanNameUrlHandlerMapping: 根据控制器名字映射到URL
ControllerBeanNameHandlerMapping: 与BeanNameUrlHandlerMapping类似, 根据控制器Bean名字将控制器
映射到URL, 使用该处理器映射实现，Bean不用遵循URL约定
ControllerClassNameHandlerMapping: 通过控制器类名作为URL基础将控制器映射到URL
DefaultAnnotationHandlerMapping: 将请求给使用@Request-Mapping注解的控制器和控制器方法
SimpleUrlHandlerMapping: 使用定义在Spring应用上下文的属性集合将控制器映射到URL

使用如上处理器只用在Spring中配置Bean,如果找不到处理器映射Bean, DispatcherServerlet将创建并使用BeanName
UrlHandlerMapping和DefaultAnnotationHandlerMapping

HomeController 首页控制器

@Controller
public class HomeController{
	public static final int DEFAULT_SPITES_PER_PAGE = 25;
	private SpitterService spitterService;										   <----- 声明为控制器			

	@Inject 
	public HomeController(Spitter spitterService){
		this.spitterService = spitterService;                                      <----- 注入Spitter Service
	}

	@RequestMapping({"/", "/home"})                                                <----- 处理对首页的请求

	public String showHomePage(Map<String, Object> model){
		model.put("spittles", spitterService.getRecentSpitters(DEFAULT_SPITERS_PER_PAGE));  <----- 将Spitter 放入模型中
		return "home";                                                             <----- 返回要渲染的视图名称
	}
}

当要为用户展现信息的时候, SpringMVC可以使用视图解析器来选择合适的视图

视图解析器

BeanNameViewResolver, ContentNegotiationViewResolver, FreeMarkerViewResolver, InternalResourceViewResolver,
JasperReportsViewResolver, ResourcesBundlerViewResolver, TilesViewResolver, UrlBasedViewResolver, VelocityViewResolver
VelocityViewResolver, XmlViewResolver, XsltViewResolver


7.2.3 完成Spring应用上下文

DispatcherServerlet 会根据一个XML文件来加载其Spring应用的上下文, 而这个文件的名字基于它的<servlet-name>属性来确定. 我们还需要一种方式
去加载其他的配置文件. 
ContextLoaderListener是一个Serverlet监听器, 能够加载其他的配置文件到一个Spring的上下文中

7.3处理控制器的输入 


@Controller
@RequestMapping("/spitter")														 <---- 根Url路径
public class SpitterController{
	private final SpitterService spitterService;

	@Inject
	public SpitterController(SpitterService spitterService){
		this.spitterService = spitterService;
	}

	@RequestMapping(value = "/spittles", method = "GET")                          <---- 处理针对spitter/spitters的GET请求 
	public String listSpittleForSpitter{
		@RequestParam("spitter") String username, Model model){                   <---- 注入参数  
			Spitter spitter = spitterService.getSpitter(username);
			model.addAttribute(spitter);
			model.addAttribute(spitterService.getSpittlesForSpitter(username));   <---- 填充模型
			return "spittles/list";
		}
	}
} 													

@RequestMapping 的 params属性能够限制处理方法只对包含特定参数的请求进行处理

7.2.4 处理表单的输入

@RequestMapping(method = RequestMethod.POST)
public String addSpitterFromForm(@Valid Spitter spitter, BindingResult bindingResult){
	if(bindingResult.hasErrors()){
		return "spitters/edit"
	}
	...
}


@Valid注解表示Spitter在传入之前需要校验

处理带有路径变量的请求 

@RequestMapping(value = "/{username}", method = RequestMethod.GET)
public String showSpitterProfile(@PathVariable String username, Model model){
	model.addAttribute(spitterService.getSpitter(username));
}

路径中{username}是占位符, 他对应了使用@Pathvariable注解的username方法参数
如果请求路径是/username/habuma 那么habuma将会作为username的值传递到showSpitterProfile()中

定义校验规则

JSR-303的定义了一些注解 

@Size(min=3, max=20, message = "Username must be between 3 and 20 characters long")			   <--- 限制长度

@Pattern(regexp = *^[a-zA-Z0-9]+$), message = "Username must be alphanumeric with no spaces*)  <--- 确保没有空格
private String username; 

@Size(min=6, max = 20, messgae= "the password must be at least 6 characters long.")    
private String password;

@Pattern(regexp = *[a-zA-Z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,4}*, message = "Invalid email address") 
private String email;

处理文件上传

在注册表单上添加一个文件上传域
修改SpitterController的addSpitterFromForm()以接收上传的文件
在Spring中配置mutipart文件处理器

public String addSpitterFromForm(@Valid Spitter spitter, BindingResult bindingResult, 
@RequestParm(value = "image", required = "false", MutipartFile image){
	try{
	if(!image.isEmpty()){
		validateImage(image);
		saveImage(spitter.getId() + ".jpg, image); 
		}
	}catch(ImageUploadException e){
		bindingResult.reject(e.getMessage());
		return "...";
	}
	return "...";
}


将文件保存在文件系统中

private void saveImage(String filename, MutipartFile image) throws ImageUploadException{
	try{
		File file = new File(webRootPath + "/resource/" + filename);
		FileUtils.writeByteArrayToFile(file, image.getBytes());
	}catch(IOException e){
		throw new ImageUploadException("Unable to save image", e);
	}
}

第八章 使用Spring Web Flow

第九章 保护Spring应用

9.4认证用户

内存(基于Spring配置) 用户存储库
基于JDBC的用户存储库
基于LDAP的用户存储库
OpenID分散式的用户身份识别系统
中心认证服务（CAS)
X.509证书
基于JAAS的提供者

9.5保护方法调用
使用 @Secure注解的方法
使用JSR-250@RolesAllowed注解的方法
使用Spring方法调用前和调用后注解的方法
匹配一个或者多个明确声明的切点的方法

9.5.1 使用@Secure注解保护方法调用

@Secure("ROLE_SPITTER")
public void addSpitter(Spitter spitter){
	//...
}

@Secure注解使用一个String数组作为参数。 每个String是一个权限,调用这个方法至少具备其中的一个权限
通过传递进来的ROLE_SPITTER, 我们告诉Spring Security只允许具有ROLE_SPITTER权限的认证用户才能调用
saveSpitter()方法

如果传递给@Secure多个权限值, 认证用户必须具备至少其中的一个条件参能进行方法的调用

9.5.2 使用JSR-250 的 @RolesAllowed注解

@RolesAllowed是JSR-250定义的Java标准注解

9.5.3 使用SpEL实现调用前后的安全性

注解 													描述
@PreAuthorize 						在方法调用之前，基于表达式的计算结果来限制方法的访问
@PostAuthorize						允许方法调用, 但是如果表达式计算结果为false, 则会抛出一个安全性异常
@PostFilter 						允许方法调用, 但必须按照表达式来过滤方法的调用
@PreFilter							允许方法调用, 但必须在进入方法之前过滤输入值

@PreAuthorize 

基于赋予用户的角色, 使用@PreAuthorize来限制访问
@PreAuthorize("hasRole('ROLE_SPITTER')")
public void addSpitter(Spitter spitter){
	//...
}

@PreAuthorize("(hasRole('Role_SPITTER') and #spittle.text.length() <= 140 or hasRole('ROLE_SPITTER')")
public void addSpittle(Spittle spittle){
	//...
}


@PostAuthorize

在调用之后验证权限

@PostAuthorize("returnObject.spitter.username == principle.username")
public Spittle getSpittleById(long id){
	//...
}


事后对方法进行过滤

需要保护的并不是被方法的调用，而是方法的返回数据

@PreAuthorize("hasRole('ROLE_SPITTER')")
@PostFilter("filterObject.spitter.username == principle.name")
public List<Spittle> getABunchOfSpittles(){
	...
}

第十章 使用远程服务

远程方法调用
* 远程方法调用 RMI
* Caucho 的 Hessian和Burlap
* Spring 自己基于HTTP的远程服务
* 使用JAX-RPC 和JAX-WS的web 服务

RPC模型                                                 适用场景
远程方法调用RMI 								不考虑网络限制时, 访问/发布基于Java的服务
Hessian或burlap								考虑网络限制时, 通过HTTP访问/发布Java的服务
Http invoker								考虑网络限制时, 并希望使用基于XML或专有的Java序列化机制, 访问发布Java服务
JAX-RPC 和 JAX-WS 							访问/发布平台中立的, 基于SOAP的Web服务

在Spring中, 远程服务被代理, 所以它们能够像其他Spring Bean一样被装配到客户端代码中

		 服务接口
		  ^  ^
         /    \
	    /	   \			
	   /  关联  \
	代理 <------	服务
	  ^  \
	  |   \
关联	  |  为远程方法调用处理网络通信细节
	  |
	客户端 



		服务接口	 
		   ^
		   |
		   |
	---------------------
	|			  		|	
	|			  		|	
服务实现Bean  <----  远程输出器  <----> 客户端
			  关联  		|	   远程通信
			  			|
			  			|
			  			|
			  		处理远程方法调用的marshalling
			  		和unmarshalling

使用RMI导出器将SpitterService的实现发布为RMI服务

10.2.1 发布一个RMI服务

1.编写一个服务实现类, 类中方法必须抛出 java.rmi.RemoteException异常
2. 创建一个继承于java.rmi.Remote的服务接口
3. 运行RMI编译器(rmic), 创建客户端Stub类和服务端Skeleton类
4. 启用RMI注册表, 以便驻留这些服务
5. 在RMI注册表中注册服务

在Spring中配置RMI服务

RMIServiceExporter可以将任意一个Spring管理的Bean发布为RMI服务.
RmiServiceExporter将Bean包装在一个适配器类中，然后适配器类被绑定到RMI注册表中，
并且将请求代理给服务器类


	SpitterService
		 |
		 |
		 |
		 |				 绑定
	SpitterServiceImpl  ----->  RMI注册表

	RmiServiceExporter通过把POJO包装到服务适配器中, 并将服务适配器绑定到RMI注册表中, 
	从而将POJO转化成RMI服务

10.2.2 装配RMI服务

try{
	String serviceUrl = "rmi:/spitter/SpitterService";
	SpitterService spitterService = (SpitterService) Naming.lookup(serviceUrl);
	...
} 
catch(RemoteException e) {...}
catch(NotBoundException e) {...}
catch(MalformURLException e) {...}

问题
1. 传统的RMI查找会导致三种检查类型异常的一种, 这些异常必须被捕获或者抛出
2. 需要Spitter服务的任何代码都必须自己负责获取该服务.这属于样板式代码, 与客户端的功能并没有直接关系


RMIProxyFactoryBean 是一个工厂Bean, 该Bean可以为RMI服务创建代理. 使用RmiProxyFactoryBean引用一个
SpitterService的RMI服务需要配置一个bean声明


		方法调用
客户端 ---------->  Spitter服务 | RMI代理 --------> 网络 ----------> Spitter服务 
							^			 JRMP消息        JRMP消息
							|
							|
							|
							|
							|
					RMIProxy FactoryBean 


RmiProxyFactoryBean生成一个代理对象, 该对象代表客户端来负责与远程的RMI服务进行通信.
客户端通过与服务的接口与代理进行交互, 就如同远程服务就是一个本地POJO

@Autowired
SpitterService spitterService;

我们可以像本地Bean一样调用
public List<Spitter> getSpittles(String username){
	Spitter spitter = spitterService.getSpitter(username);
	return spitterService.getSpittersForSpitter(spitter);
}


RMI是一种实现远程服务交互非常好的方式, 但是它存在某些限制, RMI很难穿越防火墙, 因为RMI使用任意端口来交互
--防火墙通常不允许。 RMI同时是基于Java的,意味着客户端和服务端都必须使用Java开发, 因为RMI使用了Java的序列
机制。


Hessian和Burlap 解决RMI限制的远程调用解决方案

使用Hessian 和 burlap发布bean 功能

导出一个Hessian服务



--------> Dispatch servlet --------> HessianService Explorlar 
  请求						 分发            
  											 | 
  											 |
  											 |
  											 |	
  									SpitterServiceImpl	 

HessianServiceExporter是一个SpringMVC控制器, 它可以接受Hessian请求, 并将这些请求翻译成对POJO的调用，
从而将POJO导出为一个Hessian服务

配置Hessian控制器
RmiSerivceExporter和HessianServiceExplorter另外一个区别是, HessianServiceExplorter是基于HTTP的,
所以HessianServiceExplorter实现为一个Spring MVC控制器. 这意味着为了使用导出的Hessian服务, 我们
需要执行两个额外的配置步骤

* web.xml中配置Spring的DispatchServerlet,并把我们的应用部署为Web应用
* 在Spring配置文件中配置一个URL处理器, 并将Hessian服务的URL分发给对应的Hessian服务Bean


Burlap服务类似

		方法调用
客户端 ---------->  Spitter服务 | Hessian/Burlap代理 --------> 网络 ----------> Spitter服务 
							^			              HTTP            HTTP
							|
							|
							|
							|
							|
					Hessian/Burlap FactoryBean 

HessianProxyFactory和BurlapProxyFactoryBean生成的代理对象负责通过HTTP(Hessian 2进制, Burlap XML)
与远程对象进行通信

Hessian和Burlap能穿过防火墙, 但是使用私有的对象序列化机制

Spring HTTP invoker 是一个新的远程调用模型, 作为Spring框架的一部分, 来执行基于HTTP的远程调用

10.4.1 将Bean发布为HTTP服务

导出HTTP invoker 服务, 我们需要使用HttpInvokerServiceExporter

类似上面的方法

JAX-WS端点

@WebService注解所标注的类被认为是Web服务的端点, 而使用@WebMethod所标注的方法被认为是操作

装配JAX-WS端点的秘密在于继承 SpringBeanAutowiredSupport. 我们使用@Autowired注解标注端点
的属性,依赖会自动注入


@WebService(serviceName = "SpitterService")
public class SpitterServiceEndpoint extends SpringBeanAutowiredSupport{         <------ 启动自动装配
	@Autowired
	SpitterService spitterService;                                 <------- 自动装配SpittleService

	@WebMethod
	public void addSpitter(Spittle spittle){
		spitterService.saveSpittle(spittle);              
	}

	@WebMethod
	public void deleteSpittle(long spittleId){
		spitterService.deleteSpittle(spittleId);                    <------- 委托给SpittleService
	}
}

导出独立的JAX-WS端点

Spring的SimpleJaxWsServiceExporter会搜索Spring应用上下文来查找所有使用
@WebService所标注的注解的Bean.当找到符合的Bean时, SimpleJaxWsServiceExporter
使用http://localhost:8080/地址将Bean发布为JAX-WS端点


@Component
@WebService(serviceName = "SpitterService")
public class SpitterServiceEndpoint{
	//...
}
SpitterServiceEndpoint不需要继承SpringBeanAutoWiringSupport 因为他是一个合格的Spring Bean
不需要任何继承就可以直接装配

在客户端代理JAX-WS服务


		方法调用
客户端 ---------->  Spitter服务 | JAX-WS代理 --------> 网络 ----------> Spitter服务 
							^			     SOAP消息       SOAP消息
							|
							|
							|
							|
							|
					JaxWsPortProxy FactoryBean 
JaxWsPortProxyFactoryBean生成可以与远程Web服务交互的代理，这些代理可以被装配到其他Bean中, 
就像本地POJO一样


第11章  Spring 添加Rest功能 

11.1.1  Rest基本原理

Rest
R- representational 表述性, Rest资源可以用任何形式进行表述，包括XML, JSON
S- state 状态, 我们更关注资源的状态, 而不是对资源采取的行为
T- transfer 转移, 转移资源从一个应用到另一个


Spring是如何支持REST的
* 控制器可以处理所有的HTTP方法, 以及主要的Rest方法 GET, PUT, DELETE, POST

* @PathVariable注解使得控制器能够处理参数化的URL

* Spring的视图和视图解析器

* 基于视图的渲染可以使用@ResponseBody 和HttpMethodConverter 实现, 可以将传入的
HTTP数据转化为传入控制器处理方法的Java对象

RestTemplate简化了客户端对REST资源的使用

@RequestMapping(value = "/{id}", method = RequestMethod.PUT)
@ResponseStatus(HttpStatus.NO_CONTENT)
public void putSpittle(@PathVariable("id") long id, @Valid Spitter spittle)P
	spittleService.save(spittle);


@ResponseStatus定义了HTTP状态, 这个状态设置在发往客户端的响应中. HttpStatus.NO_CONTENT说明
响应状态码要设置为204, 表示请求被成功处理, 但是不返回任何信息

Http.Status.CREATE 201表示资源被成功创建

使用POST创建新的Spittle
@RequestMapping(method = RequestMethod.POST) 

@ResponseStatus(HttpStatus>CREATE)
public @ResponseBody Spittle createSpittle(@Valid Spittle spittle, BindingResult result,
	HttpServerletResponse response) throws BindingException{
	if(result.hasErrors()){
		throw new BindingException();
	}
	spitterService.saveSpittle(spittle);
	response.setHeader("Location", "/spittles/" + spittle.getId());     <----- 设置资源位置 
	return spittle                                 <----- 返回Spittle资源
	}


使用HTTP信息转换器

@RequestMapping(value = "/{username}", method = RequestMethod.GET, headers = {"Accept=text/xml, application/json"})
public @ResponseBody
Spitter getSpitter(@PathVariable String username){
	return spitterService,getSpitter(username);
}

资源的格式需要满足请求中Accept头部信息的要求, 如果请求中没有包含Accept头部信息的话, 那就假设客户端能够接受任意的表述形式
headers 表明这个方法只接受Accpet头部信息为 text/xml / application.json的表述形式

Spring提供了多个HTTP信息转换器， 用于实现资源表述与各种Java类型之间的相互转化


信息转换器								                           描述
AtomFeedHttpMessageConverter 	         Rome Feed对象和Atom Feed(媒体类型的application/atom+xml)之间的相互转换
BufferedImageHttpMessageConverter        BufferedImages与图片2进制数据之间相互转换
ByteArrayHttpMessageConverter            读取/写入字节数组, 从所有媒体类型(*/*)中读取, 并以application/octet-stream格式写入
FormHttpMessageConverter		         将application/x-www-form-urlencoded内容
								         读入到MultiValueMap<String, String>中, 也会将MutiValueMap<String, String> 写入到
								         application/x-www-form-urlencoded
								         或者将MutiValueMap<Object, Object> 写入到mutipart/form-data中
Jaxb2RoorElementHttpMessageConverter  	 在XML(test/xml 或application/xml)和使用JAXB2注解的对象间互相读取和写入 
MappingJacksonHttpMessageConverter       在JSON和类型化对象或非类型化的Hashmap间互相读取和写入 
MarshallingHttpMessageConverter          注入使用marshaller和unmarshaller来读入和写入XML 
ResourceHttpMessageConverter 			 读取或写入Resource 默认注册
RssChannelHttpMessageConverter			 在RSS feed和Rome Channel对象间互相读取或者写入
SourceHttpMessageConverter				 在XML和javax.xml.transform.Source对象间互相读取和写入		
StringHttpMessageConverter				 将所有媒体类型(*/*)读取为String, 将String写入为text/plain
XmlAwareFormHttpMessageConverter		 FormHttpMessageConverter的扩展, 使用SourceHttpMessageConverter支持基于XML的部分

在请求体中接受资源状态

@ResponseBody 注解能够将发送给客户端的数据进行转换一样, @RequestBody也能对客户端发过来的对象做相同的事情

假设客户端提交了一个PUT请求, 在请求体中包含了JSON格式表述的Spitter对象数据, 为了以Spitter对象来接收信息,
只需在处理的方法Spitter参数上使用@RequestBody注解

@RequestMapping(value = "/{username}", method = RequestMethod.PUT,
 			headers = "Content-Type=application/json")
@ReponseStatus(HttpStatus.NO_CONENT)
public void updateSpitter(@PathVariable String username, @RequestBody Spitter spitter){
	spitterService.saveSpitter(spitter);
}

编写Rest客户端

并且所编写的代码都是样板式的, 例如: 
public Spittle[] retrieveSpittlesForSpitter(String username){
	try{
		HttpClient httpClient = new DefaultHttpClient();                      <---- 创建HttpClient
		String spittleUrl = "http://..."                                      <---- 组件url
		HttpGet getRequest = new HttpGet(spittleUrl); 						  <---- 创建对Url的请求
		getRequest.setHeader(new BasicHeader("Accept", "application/json"));  
		HttpEntity entity = response.getEntity();                             <---- 解析结果
		ObjectMapper mapper = new ObjectMapper();                          
		return mapper.readValue(entity.getContent(), Spittle[].class);        
	}catch(IOException e){
		throw new SpitterClientException("Unable to retrieve Spittle", e); 
	}
}

最好的方法是使用RestTemplate封装代码并令参数可变

了解RestTemplate的操作

RestTemplate所提供的11个独立方法

方法                                描述
delete()                       	在特定的URL上对资源执行HTTP DELETE操作  
exchange()						在URL上执行特定的HTTP方法, 包含返回对象的ResponseEntity, 这个对象是从响应体中映射到的
execute() 						在URL上执行特定的HTTP方法, 返回一个响应体映射得到的对象
getForEntity()					发送一个HTTP GET请求, 返回的ResponseEntity包含了响应体所映射成的对象
getForObject()					GET资源, 返回的请求体将映射为一个对象
headForHeaders()				发送HTTP HEAD请求, 返回包含特定资源URL的HTTP头
optionsForAllow() 				发送HTTP OPTION请求, 返回对特定资源URL的Allow头信息
postForEntity()					POST数据, 返回包含一个对象的ResponseEntity, 这个对象是从响应体中映射得到的
postForLocation() 				POST数据, 返回新资源的URL
postForObject() 				POST数据, 返回请求体将匹配为一个对象
put()							PUT资源到特定的URL

3种方法进行了重载
一个使用java.net.URI作为URL格式, 不支持参数化URL
一个使用String作为URL格式, 并使用Map指明URL参数
一个使用String作为URL格式, 并使用可变参数列表指明URL参数

GET资源

3个getForObject()方法签名

<T> T getForObject(URI url, Class<T> responseType) throws RestClientException;

<T> T getForObject(String url, Class<T> responseType, Object... uriVariable) throws RestClientException;

<T> T getForObject(String url, Class<T> responseType, Map<String, ?> uriVariables) RestClientException;

只返回所请求类型的对象

类似的

<T> ResponseEntity getForEntity(URI url, Class<T> responseType) throws RestClientException;

<T> ResponseEntity getForEntity(String url, Class<T> responseType, Object... uriVariable) throws RestClientException;

<T> ResponseEntity getForEntity(String url, Class<T> responseType, Map<String, ?> uriVariables) RestClientException;

返回请求的对象以及响应相关的额外信息

getForObject() 方法是检索资源合适的选择, 你请求一个资源并以你所选择的Java类型接收该资源.

public Spittle[] retrieveSpittlesForSpitter(String username){
	return new RestTemplate().getForObject("http://localhost:8080/Spitter/spitter/{spitter}/spittles",
	 Spittle.class, username);
}

没有使用字符串连接来构建URL, 而是使用RestTemplate可以接受参数化URL这一功能. URL中的{spitter}占位符最终将会用方法的username
参数来填充。getForObject()方法最后一个是参数大小可变的参数列表, 每个参数都会按顺序插入到URL的占位符中.

替代方式是将username参数放到Map中, 并以spitter作为key, 然后将这个map作为最后一个参数传递给getForObject()
public Spittle[] retrieveSpittlesForSpitter(String username){
	Map<String, String> urlVariables= new HashMap<String, String>(); 
	urlVariables.put("spitter", username);
	return new RestTemplate().getForObject(
	"http://localhost:8080/Spitter/spitters/{spitter}/spittles", Spittle[].class, urlVariables
	);
}

抽取响应的元数据

getForEntity() 在ResponseEntity中返回相同的对象. ResponseEntity还带有关于响应的额外信息，如HTTP状态码和响应头
ResponseEntity的一个用途是获取响应头的一个值, 想知道资源的最后修改时间, 假设服务端在Last-Modified头中提供了这个信息
, 可以这样使用getHeaders()方法

Date lastModified = new Date(response.getHeaders().getLastModified());

getHeaders()方法还包含以下的方法获取头信息
public List<MediaType> getAccept(){...}
public List<Charset> getAcceptCharset{...}
public Set<HttpMethod> getAllow(){...}
public String getCacheControl(){...}
public long getContentLength(){...}
public MediaType getContentType(){...}
public long getDate(){...}
public String getETag() {...}
public long getExpires() {...}
public long getIfNotModifiedSince() {...}
public List<String> getIfNoneMatch() {...}
public long getLastModified() {...}
public URI getLocation() {...}
public String getPragma() {...}

更通用的HTTP头信息的访问, HttpHeaders提供了get()方法和getFirst()方法 get()将会返回一个String值的列表
getFirst()只返回第一个头信息的值

PUT资源 

3个put资源方法签名

void put(URI url, Class<T> responseType) throws RestClientException;

void put(String url, Class<T> responseType, Object... uriVariable) throws RestClientException;

void put(String url, Class<T> responseType, Map<String, ?> uriVariables) throws RestClientException;

以下如何使用基于URL版本的put() 来更新服务器上的Spittle资源: 

public void updateSpittle(Spittle spittle) throws SpitterException{
	try{
		String url = "http://localhost:8080/Spitter/Spitter/spitters/" + spittle.getId();
		new RestTemplate().put(new URI(url), spittle);
	}catch (URISyntaxException e){
		throw new SpitterUpdateException("Unable to update spittle", e);
	}
}

public void updateSpittle(Spittle spittle) throws SpitterException{
	restTemplate.put("http://localhost:8080/Spitter/spitter/{id}", spittle, spittle.getId());
}

DELETE资源

类似put

POST资源

3种 postForObject()

3种 postForEntity()

类似get...()

在POST请求后获取资源位置
对于要同时发送资源和响应头来说 postForEntity()方法是很便利的, 但通常不需要将资源发回来, 如果只需要的是
Location头信息的值, 那么使用RestTemplate的postForLocation()方法会更简单 

响应是新创建资源的位置

URI postForLocation(String url, Object request, Object... uriVariables) throws RestClientException;

URI postForLocation(String url, Object request, Map<String, ?> uriVariable) throws RestClientException;

URI postForLocation(URI url, Object request) throws RestClientException;

交换资源 

在发送服务端的请求中设置头信息的话, 使用exchange()

<T> ResponseEntity exchange(URI url, HttpMethod method, HttpEntity<?> requestEnity, Class<T> responseType) throws RestClientException;

<T> ResponseEntity exchange(String url, HttpMethod method, Class<T> responseType, Object... uriVariable) throws RestClientException;

<T> ResponseEntity exchange(String url, HttpMethod method, Class<T> responseType, 
Map<String, ?> uriVariables) RestClientException;

不指明头信息的使用

ResponseEntity<Spitter> response = rest.exchange("http://localhost:8080/Spitter/spitters{spitter}",
		HttpMethod.GET, null, Spitter.class, spitterId);
Spitter spitter = response.getBody();

指明头信息的使用

先创建一个LinkedMutiValueMap 并添加值为application/json的Accept头信息
MutiValueMap<String, String> headers = new LinkedMutiValueMap<String, String>();
headers.add("Accept", "application/json");
HttpEntity<Object> requestEntity = new HttpEntity<>(headers);
构造一个HttpEntity, 将LinkedMutiValueMap传入
传入HttpEntity调用exchange()
ResponseEntity<Spitter> response = rest.exchange("http://localhost:8080/Spitter/spitters/{Spitter}", 
		HttpMethod.GET, requestEntity, Spitter.class, spitterId);
Spitter spitter = response.getBody();

11.5 提交Restful表单

POST伪装
通过使用HiddenHttpMethodFilter来进行请求转换

Spring消息 

JMS 简介
像RMI和Hessian/Burlap这样的远程调用是同步的, JMS提供了应用之间的异步通讯机制.

JMS主要两个概念 
message broker 消息代理 
destination 目的地

点对点消息模型

发送者    ------->  队列  -------> 接收者

消息队列对消息发送者和接受者进行了解耦, 虽然队列可以有多个接收者, 但是每条消息只能被一个接收者取走

尽管消息队列中的每条消息只投递给一个接收者, 但是并不意味着只能使用一个接收者从队列获取消息, 可以使用多
个接收者来处理队列中的消息

发布-订阅者模型 
						  订阅者
					    /	
 					   /	
					  /	
发送者  ------> 主题  ---- 订阅者
					  \
					   \
					    \ 订阅者

与队列类似, 主题可以将消息发送者与消息接收者进行解耦, 与队列不同的是, 主题消息可以发送给多个主题订阅者

同步机制的缺点
1. 等待
2. 客户端通过服务接口与远程服务相耦合
3. 客户端与远程服务位置耦合
4. 客户端与远程服务可用性耦合

JMS的优点
1. 无需等待
2. 面向消息和解耦 
3. 位置独立
4. 确保投递  	

Spring中搭建消息代理
ActiveMQ 现有以及不推荐使用 推荐使用RabbitMQ RocketMQ或者kafka

JmsTemplate Spring对JMS的核心支持部分

JmsTemplate跟JdbcTemplate一样, 用于处理复杂失控的连接代码

使用JMS模板

JmsTemplate可以创建连接, 获得会话, 以及发送和接受消息, 并可以处理JMSException异常
Spring的JmsTemplate捕获标准的JMSException异常, 再以Spring自己的非检查型异常JmsException
子类重新抛出

Spring(org.springframwork.jms.*)      							标准的JMS(javax.jms.*)
DestinationResolutionException					Spring特有的--当Spring无法解析目的地名称时弹出
IllegalStateException							IllegalStateException
InvalidClientIDException						InvalidClientIDException
InvalidSelectorException						InvalidSelectorException
JmsSecurityException							JmsSecurityException
ListenerExecutionFailedException				Spring特有的--当监听器方法执行失败时抛出
MessageConversionException						Spring特有的--当消息转换失败时抛出
MessageEOFException								MessageEOFException
MessageFormatException							MessageFormatException
MessageNotReadableException						MessageNotReadableException
MessageNotWriteableException					MessageNotWriteableException
ResourcesAllocationException					ResourcesAllocationException
SynchedLocalTransactionFailedException			Spring特有的--当同步的本地事务不能完成时抛出
TransactionInProgressException					TransactionInProgressException
TransactionRollBackException					TransactionRollBackException
UncategorziedJmsException						Spring特有的--当没有其他异常适用时候抛出

都是检查型异常 必须要捕获


使用JmsTemplate发送一个Spittle

public class AlertServiceImpl implements AlertService{
	@Autowired
	JmsTemplate jmsTemplate;													<---- 注入JMS模板

	public void sendSpittleAlert(final Spittle spittle){
		jmsTemplate.send{                                                          <---- 发送消息
			"spittle.alert.queue", new MessageCreator(){						   <---- 指定目的地
				public Message createMessage(Session session) throws JMSException{ 
					return session.createObjectMessage(spittle);				<---- 创建消息
				}
			}
		}
	}
}

			send()
消息发送者 ----------> JmsTemplate --------> 队列/主题

JmsTemplate 代表发送者来负责处理发送消息的复杂过程

使用 MessageCreator来构造消息, 在MessageCreator的 createMessage()方法中, 通过session创建了一个对象消息
传入一个Spittle对象, 返回一个对象消息

可以设置默认目的地, 减少参数

Jms接收消息

public Spittle getAlert(){
	try{
		ObjectMessage receivedMessage = (ObjectMessage) jmsTemplate.receive();		<---- 接收消息
		return (Spittle) receivedMessage.getObject();                               <---- 获得对象
	}catch(JMSException jmsExceptin){
		throw JmsUtils.convertJmsAccessException();									<---- 抛出转换后的异常
	}
}

当调用JmsTemplate的receive() 方法时, JmsTemplate会尝试从消息代理中获取一个消息, 如果没有可用消息, receive()
方法会一直等待, 直到获得消息为止.

									receive()
队列/主题 -----------> JmsTemplate <----------- 消息接收者

使用JmsTemplate从主题或队列中接收消息只需要简单点地调用receive()方法. JmsTemplate会处理其余所有事项

使用JmsTemplate最大缺点在于receive() 方法是同步的, 因此receive()方法会一直阻塞

创建消息驱动的POJO

Spring使用消息驱动POJO来支持异步接收消息的


EJB2引入消息驱动Bean, MDB 是可以异步处理消息的, 唯一缺点是必须实现javax.ejb.MessageDrivenBean和生命周期

@MessageDriven(mappedName = "jms/spittle.alert.queue")
public class SpittleAlertHandler implements MessageListener{
	@Resource
	private MessageDrivenContext mdc; 

	public void onMessage(Message message){
		...
	}
}

EJB3的规范的MDB实现该需求并不会太难, 但事实上, SpittleAlertHandler的EJB3实现太依赖于EJB的消息驱动API, 
并不是我们所希望的POJO

Spring提供了能以POJO方式处理消息的能力, 这些消息来自JMS队列或主题中. 

public class SpittleAlertHandler{
	public void processSpittle(Spittle spittle){
		...
	}
}

队列/主题  ----------> 消息监听器容器 --------> 消息监听器

消息监听器容器监听队列和主题, 当消息到达时, 消息将转给消息监听器

基于消息的RPC 

使用JMS作为传输通道来进行远程调用,通过队列和主题在应用程序间发送消息

Spring 自身提供了2种RPC

Spring 自身提供JmsInvokerServiceExporter, 可以把Bean导出为基于消息的服务; 为客户端提供了
JmsInvokerProxyFactoryBean 来使用这些服务

Lingo通过它的JmsServiceExporter和JmsProxyFactoryBean提供了类似的基于消息的远程服务调用

Spring提供多种方式将Bean导出为远程服务

RmiServiceExporter将Bean导出作为JRMP的RMI服务

使用Hessian/Burlap的Hessian/BurlapExporter基于HTTP的服务

使用HttpInvokerServiceExporter创建基于HTTP的HTTP invoker服务

JmsInvokerServiceExporter用于导出基于JMS的服务

一个简单的AlertService接口

public interface AlertService{
	void sendSpittleAlert(Spittle spittle);
}

AlertService使用 @Componenet来进行标注, 它会在Spring上下文自动发现并注册为Spring应用上下文的ID为alertService的bean

在配置JmsInvokerServiceExporter时, 我们将引用这个bean

基于JMS的提醒服务已经配置好了 等待队列名为spittle.queue的RPC消息到达

访问基于JMS的服务

JmsInvokerProxyFactoryBean用来访问服务, 与代理RMI服务或者基于HTTp服务最大区别在于, JmsInvokerProxyFactoryBean代理
通过JmsInvokerServiceExporter所导出的JMS服务

为了访问提醒服务, 我们需要配置JmsInvokerProxyFactoryBean
<bean> ... </bean> 

connectionFactory 和queryName 指定了RPC消息如何被投递, 
serviceInterface指定了该代理应通过AlertService接口发布.

12.5.2 使用Lingo实现异步RPC 

Lingo充分利用了JMS异步特性实现异步调用服务, Lingo并不是Spring框架的一部分, 它是基于Spring远程机制而构建的独立项目
, 提供了基于JMS的服务导出器和客户端代理.

导出异步服务

使用Lingo的JmsServiceExporter导出异步服务

JmsServiceExporter和JmsInvokerServiceExporter通过Bean进行配置

service-ref和serviceInterface属性与JmsInvokerService对应配置完全相同

因为JmsService在Spring监听器容器中不能被用作消息监听器, 所以我们必须通过ConnectionFactory属性配置JMS的连接工厂
,通过destination属性配置消息目的地, 这样JmsServerExporter才知道如何发送消息

destination-ref属性是javax.jms.Destination对象, 所以需要装配一个目的地Bean引用. 下面的alertServiceQueue Bean
将确保JMS RPC消息通过名为spittle.alert.queue队列进行传输

代理异步服务

Lingo的JmsProxyFactoryBean 可以把没有返回值的方法作为异步方法. 

配置基于Lingo的提醒服务的客户端

<bean> ... <bean> 

connectionFactory, destination-ref 和serviceInterface 属性与前一个示例的含义是相同的. metadataStrategy的属性是新的
我们使用SimpleMetadataStrategy内部Bean声明来配置该属性

13章 JMX管理Spring Bean

JMX Java 管理拓展

用的少省略

14章 其他Spring技巧 

14.1外部化配置 

Spring自带几个选项, 可以借助他们将Spring配置细节信息外部化到属性文件中, 这样就能在部署的应用之外进行管理

属性占位符配置 Property placeholder configurer 会将占位符内部变量替换为外部属性文件的值

属性重写Property override 会将Bean属性的值用外部属性文件值进行重写

14.1.1
替换属性占位符
配置@Value注解的属性

如果一个属性需要使用JDBC URL  
@Value("${jdbc.url}")
String databaseUrl;

属性文件自身使用占位符变量 
例如使用占位符变量将 jdbc.url属性拆分为多个部分 

jdbc.protocol=hsqldb:hsql
db.server=localhost
db.name=spitter
jdbc.url=jdbc:${jdbc.protocal}://${db.server}/${db.name} 

装配默认值
如果占位符变量无法在db.properties文件中找到, 那么 将使用defaultConfiguration Bean中的默认值

14.2装配JNDI对象 

Java 命名和目录接口 (java naming and directory interface)

通过名字查找对象的API

传统的JNDI API 需要复杂的代码

通过依赖注入解决, 使代码能接收任何地方的数据源, 而不是从JNDI中查找数据源. 你的代码应该有一个用于进行
注入的DataSource属性, 这个类不需要关心对象从哪里来

装配JNDI对象

14.3.2 构建邮件

使用Spring的MailSender发送邮件 

public void sendSimpleSpittleEmail(String to, Spittle spittle){
	SimpleMailMessage message = new SimpleMailMessage();    <------ 构造信息
	String spitterName = spittle.getSpitter().getFullName();   
	message.setFrom("noreply@spitter.com")                  <----- 邮件地址
	message.setTo(to);
	message.setSubject("New spittle from"+spittleName);
	message.setText(spitterName+" says: "+ spittle.getText()); <----- 设置信息文本   
	mailSender.send(message);  	  							 <----- 发送邮件 
}


添加附件

创建mutipart类型的信息 -- 邮件将由多个部分组成, 一部分邮件体, 其他部分是附件

对于发送附件来说, SimpleEmailMessage 过于简单, 发送Mutipart的邮件, 使用MIME

MimeMessageHelper简化了发送带有附件的邮件

public void sendSpittleEmailWithAttachment(String to, Spittle spittle) throws MessagingException{
	MimeMessage message = mailSender.createMimeMessage();             <---- 邮件发送器对象
	MimeMessageHelper helper = new MimeMessageHelper(message, true);  <---- 构造信息的 helper
	String spitterName = spittle.getSpitter().getFullName();  		
	helper.setFrom("noreply@spitter.com");
	helper.setTo(to);
	helper.setSubject("New spittle from "+ spitterName);
	helper.setText(spitterName + " say: "+ spitter.getText());
	FileSystemResources couponImage = new FileSystemResource("*/collateral/coupon.png"); 
	helper.addAttachment("Coupon.png, couponImage");                  <---- 添加附件
	mailSender.send(message);
}

发送带有丰富文本内容的邮件 

将信息的文本设置为HTML, 要做到这一点只需要将HTML字符串传递给helper的setText()方法, 并将第二个参数设为true.

添加嵌入式图片不用addAttachment()方法, 使用addInline() 方法 

ClassPathResource image = new ClassPathResource("spittle_logo_50.png");
helper.addInline("spitterLogo", image);

addInline 第一个参数表面内联图片的标识符, 与<img> src属性相同
第二个参数是图片资源引用, ClassPathResource的类路径获取图片

使用Apache Velocity配置模板引擎
Apache Velocity VS freemarker 
 简单好学 			功能强大

 Spring提供了一个名为VelocityEngineFactoryBean的工厂Bean, 它能够在Spring应用上下文中很便利的生成VelocityEngine

 依赖注入Velocity引擎
 @Autowried
 VelocityEngine velocityEngine;

 Spring自带VelocityEngineUtils来简化将Velocity模板与模型数据合并成String的工作
 Map<String, String> model = new HashMap<>();
 model.put("spitterName", spitterName);
 model.put("spitterText", spittle.getText());
 String emailText = VelocityEngineUtils.mergeTemplateIntoString(
 	velocityEngine, "emailTemplate.vm", model); 


14.4调度和后台任务

两种后台任务可供选择
1. 调度任务
2. 异步方法


14.4.1 声明调度方法 
@Scheduled(fixedRate = 86400000) 
public void acrhievOldSpittle(){
	...
}

fixRate 这次开始和下次开始时间的间隔
fixDelay 这次完成和下次开始之间的间隔
cron = Corn表达式 指定何时进行调用

6个空格分隔的元素构成
秒(0-59) 分钟(0-59) 小时(0-23) 日 (1-31) 月 (1-12) 星期(1-7) 年 (1970)
, 表示多个 ? 表示不设定  1-30可以设置范围 * 通配符

14.4.2 声明异步方法

实际性能 actual performance指的是独立测量完成一项操作需要多长时间
感知性能 perceived performance指的是用户感受到变化所需要的时间

@Async将其放到Bean方法上, 这个方法就会成为异步的了

Spring的异步方法是建立在Java的并发API之上的, 它可以返回java.util.concurrent.Future对象
这个接口代表了一个值的容器, 而值能在方法返回的某个时间内得到, 但并不一定是方法返回的时间点

Spring还自带一个Future便利实现, 名为AsyncResult, 更容易处理未来值

假设一个异步方法要执行复杂和长时间运算, 希望在后台看到执行方法, 还想再方法执行完成时马上看到结果
@Async
public Future<Long> performSomeReallyHairyMath(long int){
	...
	return new AsyncResult<Long>(result); 
}

一旦得到结果, 调用者可以用Future() 对象的get()方法得到它, 在此之前, 调用者可以使用isDone() 和
isCancelled() 来判断结果状态

本书完

