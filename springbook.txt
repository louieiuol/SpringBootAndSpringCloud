I 第一部分 Spring的核心


Spring采用以下4种关键策略降低Java开发的复杂性：
1. 基于POJO的轻量级和最小入侵性编程
2. 通过依赖注入和面向接口实现松耦合
3. 基于切面和惯例进行声明式编程
4. 通过切面和模版减少样板代码


装配Bean
1. 创建Spring配置
 Spring是一个基于容器的框架，我们需要配置Spring来告诉它需要加载哪些Bean和如何装配这些Bean
 两种配置Bean的方式
 1.XML文件
 2.Java注解

Bean在XML中的位置
在XML文件中声明Bean，Spring配置文件的根元素是来源于Spring Bean命名空间所定义的<bean>元素：
<beans xmlns=""
      xmlns:xsi=""
      xsi:schemaLocation="">
      <!-- bean declarations go here -->
</beans>

Java自带多种XML命名空间，通过这些命名空间可以配置Spring容器
aop 声明切面以及将@AspectJ注解的类代理为Spring切面提供配置元素
beans 支持声明Bean和装配Bean
context 为配置Spring 应用上下文提供了配置元素，包括自动检测和自动装配Bean,注入非Spring直接管理的对象
jee 为声明消息驱动的POJO提供了配置元素
lang 配置由Groovy, JRuby, BeanShell等脚本实现的Bean
mvc 启动Spring MVC的能力 例如面向注解的控制器, 视图控制器，和拦截器
oxm 支持Spring对象到XML的映射配置
tx 提供声明式事物配置
util 工具类元素

声明一个Bean

<bean id="duke
      class="om.spring.springidol.Juggler" />

      <bean> 元素是Spring中最基本的配置单元，通过该元素Spring将创建一个对象。id属性定义了Bean的名字，也作为Bean在Spring容器中的引用.

通过构造器注入

1. 使用默认的构造器
2. 带一个int参数的构造方法

XML声明方式
<bean id="duke"
      class="com.spring.springidol.Juggler">
      <constructor-arg value= "15"/>
</bean>

扩展成一个PoeticJuggler
<bean id="duke"
      class="com.spring.springidol.Juggler">
      <constructor-arg value= "15"/>
      <constructor-arg ref="sonnet29" />
</bean>
逻辑类似于
Poem sonnet29 = new sonnet29();
Performer duke = new PoeticJuggler(15, sonnet29);

通过工厂方式创建Bean
Spring 支持通过<bean>元素的factory-method属性来装配工厂创建的Bean
<bean id= "theStage"
      class = "com.spring.springidol.Stage"
      factory_method = "getInstance" />

Bean的作用域
所有的Bean默认都是单列

如何让容器分配Bean时，每次请求都产生一个新的实例？
只需要配置Bean的scope属性为prototype即可
<bean id="ticket"
      class="com.spring.springidol.Ticket" scope = "prototype"/>
其他的作用域选项
singleton 在每一个Spring容器中，一个Bean定义只有一个对象实例 默认
prototype 允许Bean被实例化任意次
request 在一次HTTP请求中，每个Bean定义对应一个实例 仅web有效
session 一个HTTP session中 每个Bean对应一个实例 仅web有效

Bean的初始化和销毁
使用 init-method和destroy method参数来配置<bean>元素
<bean id = "auditorium"
      class = "com.spring.springidol.Auditorium"
      init-method = "turnOnLights"
      destroy-method = "turnOffLights" />
另一种方案是实现InitializingBean和DisposableBean接口

注入Bean属性
简单的赋值 使用property标签
<bean id="kenny"
      class = "com.spring.springidol.Instrumentalist"
      <property name = "song" value = "Jingle Bells" />
</bean>

用其他Bean赋值 使用ref
<bean id="kenny2"
      class ="come.spring.springidol.Instrumentalist">
      <property name = "song" value ="Jingle Bells"
      <property name = "instrument" ref = "saxophone" />
</bean>
调用Bean
ApplicationContext ctx = new ClassPathXmlApplicationContext("com/spring/springidol/spring-idol.xml");
Performer performer = (Performer) ctx.getBean("kenny");
performer.perform();

注入内部Bean

<bean id="kenny"
      class = "com.spring.springidol.Instrumentalist">
      <property name = "song" value = "Jingle Bells" />
      <property name = "instrument">
        <bean class= "springinaction.springidol.Saxophone" />
      </property>
</bean>

装配集合

<list> 装配list类型的值
<set> 装配set类型的值 不允许重复
<map> 装配map类型的值 名称和值可以是任意类型
<props> 装配properties类型的值 名称和值都必须是String型

2.3 使用表达式装配
Spring Expression Language SpEL 一种强大简洁的装配方式

3.最小化Spring XML配置

自动装配 autowiring 减少<property> 元素和 <constructor-arg> 元素
自动检测 autodiscovery 更进一步自动识别哪些类需要配置为bean

4种类型的自动装配

byName 把与Bean属性具有相同名字(或id)的其他Bean自动装配到Bean对应的属性中
byType 把与Bean属性具有相同类型的其他Bean自动装配到该Bean的对应属性中
constructor 把与Bean的const 具体相同类型的其他Bean自动装配到Bean构造器对应args中
autodetect 首先尝试用const进行装配失败了尝试byType

3.2使用注解装配

Spring容器默认禁用注解装配 在使用基于注解的自动装配前 需要在Spring配置中启动它，
<context:annotation-config>

3种自动装配注解
1. @Autowired
2. @Inject
3. @Resource

1.@Autowired
可以对方法进行标注
@Autowired
public void setInstrcument(Instrument instrument){
	this.instrucment = instrucment
}
可以对构造器进行标注
@Autowired
public Instrumentalist(Instrument instrument){
	this.instrucment = instrucment
}
可以直接标注属性
@Autowired
private Instrument instrument;

可选的自动装配
1. 强契约，所标注的属性或者参数必须是可以装配的
2. Null 也可以接受 @Autowired(required = false)

多个Bean满足装配条件时，使用@Qualifier注解
@Autowired
@Qualifier("guitar")
private Instrument instrument;

还可以使用@Qualifier标注Guitar类
@Qualifier("stringed")
public class Guitar implements Instrument{
	...
}

创建自定义的限定器(Qualifier)

创建@Stringedinstrument注解来充当限定器

@Target({ElementType.FIELD, ElementType.PARAMETER, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Qualifier
public @interface StringInstrument{...}

可以用它来代替Qualifier

@StringedInstrument
public class Guitar implements Instrument{...}

2.@Inject
类似Autowired

3.注解中使用表达式
@Value("Eruption")
private String song;

@Value("#{SystemProperties.myFavoriteSong}")
private String song;

自动检测Bean
<context:component-scan> 允许Spring自动检测Bean和定义Bean

标注Bean
@Component 通用的构造型组件，标识为Spring组件
@Controller 标识为SpringMVC里的controller
@Repository 标识为数据仓库
@Service 标识该类为服务

过滤组件扫描
<context: include-filter> 的type和expression属性一起协作来定义组件扫描策略
过滤器类型
1.annotation 过滤器扫描使用指定注解所标注的类，通过expression属性指定要扫描的注解
2.assignable 过滤器扫描派生于expression属性所指定的类型的那些类
3.aspectj  过滤器扫描与expression属性所指定的AspectJ表达式所匹配的那些类
4.custom 自定义
5.regex 扫描正则表达式匹配的类

3.4 使用Spring基于Java的配置
在基于Java配置里使用@Configuration注解的Java类，就等价于XML配置中的<bean>元素

定义一个配置类
在基于Java的配置里使用@Configuration注解的Java类就等价于XML配置中的<beans>元素

@Configuration
public class SpringIdolConfig{
  //Bean declaration methods go here
}

@Configuration注解作为一个标识告知Spring：这个类包含一个或多个Spring Bean的定义，这些Bean定义是使用@Bean注解所标注的方法

声明一个简单的Bean
使用@Bean注解标注一个方法来定义duke Bean

@Bean
public Performer duke(){
  return new Juggler();
}

使用Spring基于Java的配置进行注入

使用Spring基于Java编写一个返回类实例的方法 直接传值
为Bean装配另一个Bean的引用

@Bean
public Performer poeticDuke(){
  return new PoeticJuggler(sonnet29());
}
不会让方法产生新的实例

4. 面向切面的Spring

通知（Advice)
5种类型
Before 在方法被调用之前调用通知
After 在方法完成后调用通知, 无论方法执行成功与否
After-returning 在方法成功执行之后调用通知
After-throwing 在方法抛出异常之后调用通知
Around 通知包裹了被通知的方法，在被通知的方法调用之前和调用之后 执行自定义的行为

连接点（JoinPoint)
连接点是在应用执行的过程中能够插入切面的一个点，这个点可以是调用方法，抛出异常，修改字段时，切面代码可以利用这些点插入到应用的正常流程之中，
并添加新的行为

切点（Pointcut)
切点的定义会匹配通知所要织入的一个或多个连接点，通常使用明确的类和方法名称来指定这些切点，或者是利用正则表达式定义匹配的类和方法名称

切面 （Aspect）
切面是通知和切点的结合

引入（Introduction）
引入允许我们向现有的类添加新的方法和属性

织入（Weaving）
织入是将切面应用到目标对象来创建新的代理对象的过程。切面在指定的连接点被织入到目标对象中，在目标对象的生命周期里有多个点可以进行织入。

编译期-切面在目标类编译时被织入,比如ApsectJ织入编译器

类加载器-切面在目标类加载到JVM时被织入

运行期-切面在应用运行的某个时刻被织入，在织入切面时，AOP容器会为目标对象动态的创建一个代理对象。Spring AOP

Spring提供4种AOP支持
1.基于代理的经典AOP 只支持方法连接点
2.@AspectJ注解驱动的切面
3.纯POJO切面
4注入式AspectJ切面

1.经典AOP
代理类封装了目标类，并拦截被通知的方法的调用，再将调用转发给真正的目标Bean

2.AspectJ
Spring仅支持AspectJ切点指示器的一个子集，Spring是基于代理的，而某些切点表达式是与基于代理的AOP无关的
Spring AOP所支持的AspectJ切点指示器

arg() 指定类型的方法
@args() 指定注解标注的执行方法
execution() 用于匹配是连接点的执行方法
this() 限制连接点匹配AOP代理的Bean引用为指定类型的类
target() 匹配目标对象为指定类型的类
@target() 匹配特定的执行对象，对象对应的类要具备指定类型的注解
within() 匹配指定的类型
@within() 匹配注解所标注的类型
@annotation 匹配带有指定注解的连接点

编写切点

execution(*com.spring.springidol.Instrument.play(..))

execution() 方法返回时候触发（连接点的执行方法）
* 返回任意类型
com.spring.springidol.Instrument 方法所属的类
.play 此方法
(..) 参数匹配

如果仅仅匹配com.spring.springidol包
可以用within()指示器来限制匹配
execution(*com.spring.springidol.Instrument.play(..)) && within(com.spring.springidol.*)

&& || !都可以适用

bean()指示器
允许我们在切点表达式中使用Bean的ID来标识Bean bean使用 BeanID或Bean名称作为参数来限制切点只匹配特定的Bean

在执行Instrument的play() 方法时应用通知，但限定Bean的ID为eddie

execution(* com.spring.springidol.Instrument.play()) and bean(eddie)

声明环绕通知
如果不使用成员变量储存信息，那么在前置通知和后置通知之间共享信息非常麻烦,因为Audience是单例，如果像这样保存状态，它将存在现成安全问题
为了避免使用成员变量中保存开始时间，使用环绕通知在这点上有明显优势, 在一个方法内实现前置通知和后置通知所实现的相同功能，不需要使用成员变量。


public void watchPerformance(ProceedingJoinPoint JoinPoint){
long start = System.currentTimeMillis();  <- 之前
joinPoint.proceed();                      <- 执行方法
long end = System.currentTimeMillis();    <- 之后
}

ProceedingJoinPoint 能让我在通知里调用被通知方法
通知方法可以完成任何它所需要做的事情，而且如果希望把控制转给被通知的方法时, 我们可以调用ProceedingJoinPoint的proceed()方法

用于解决跨服务调用超时问题: 
hystrix:
  metrics:
    enabled: true
  command:
    default:
      execution:
        timeout:
          enabled: false

3. AOP 配置元素                                       描述
<aop: advsior>                  定义AOP通知器
<aop: after>                    定义AOP后置通知
<aop: after-returning>          定义AOP after-returning 通知
<aop: after-throwing> 			定义 after-throwing 通知
<aop: around>                   定义AOP环绕通知
<aop: aspect> 					定义切面
<aop: aspect-autoproxy> 		启动@AspectJ注解驱动的切面
<aop: before> 					定义 AOP前置通知
<aop: config> 					顶层的AOP配置元素, 大多的<aop:*> 元素必须包含在<aop:config> 元素内
<aop: declare-parents> 			为被通知的对象引入额外的接口，并透明的实现
<aop: pointcut> 				定义切点


前置声明和后置通知

<aop:config>
	<aop:aspect ref = "audience"> 
		<aop:before pointcut = "execution(* com.springinaction.springidol.Performer.perform(..))*"
			method="takeSeats" />
		<aop:after-returning pointcut= "execution(* com.springinaction.springidol.Performer.perform(..))"
			method="applaud" />
		<aop:after-throwing pointcut= "execution (* com.springinaction.springidol.Performer.perform(..))"
			method="demandRefund" />
	</aop: aspect> 
</aop:config> 	

为了避免重复定义切点，使用<aop: pointcut>元素定义一个命名切点
<aop:pointcut id="performance" expression= "*execution(*com.springinaction.springidol.Performer.perform(..))" />
引用该切点
<aop:before pointcut-ref="performance" method="takeSeats" />

4.4注解切面

@AspectJ进行标注

@Pointcut注解用于定义一个可以在@AspectJ切面内可重用的切点，注解的值是一个切点表达式

因为Audience类本身包含了所有它所需要定义的切点和通知，所以我们不需要在XML中配置声明的切点和通知。最后一件需要做的事是让Spring将
Audience应用为一个切面。我们需要在Spring上下文中声明一个自动代理Bean,该Bean如何把@AspectJ注解所标注的Bean转变为代理通知
为此Spring自带了名为AnnotationAwareAspectJAutoProxyCreator的自动代理创建类。我们需要在Spring上下文中把AnnotationAwareAspectJ
toProxyCreator注册为一个bean, 简化这样的操作，我们在aop命名空间中提供了<aop:aspectj-autoproxy/>，在Spring上下文中创建一个类，
它会自动代理一些bean. 

<aop:aspect> 相比于@AspectJ的优势是不需要源码

注解环绕通知 @Around 需要一个ProceedingJointPoint对象 作为方法入参，并在对象上调用proceed()方法

传递参数给所标注的通知
@Pointcut ("execution (* com.springinaction.springidol. ") + "Thinker.thinkOfSomething(String")) && args(thoughts)*)
public void thinking(String thoughts){}

@Before("thinking(thoughts")*)
public void interceptThoughts(String thoughts){
	System.out.println("Intercepting volunteer's thoughts: "+ thoughts);
	this.thoughts = thoughts;
} 

@DeclareParents 等价于 <aop:declare-parents> 

@AspectJ
public class ContestantIntroducer{

-----------引入Contestant接口-------------------
@DeclareParents(
value = "com.springinaction.springidol.Performer+". 
defaultImpl = "GraciousContestant.class"
)

public static Contestant contestant;
}

Contestant 为Performer Bean 引入了Contestant接口
@DeclareParents 注解3部分组成
value 属性等同于<aop:declare-parents>的types-matching属性，它标识应该被引入指定接口的Bean类型
defaultImpl属性等同于<aop:declare-parents>的default-impl属性。它标识该类提供所引入接口的实现
由@DeclareParents 注解所标注的static属性指定了将被引入的接口

4.5注入AspectJ切面

使用Spring 依赖注入把Bean装配进AspectJ切面中
public aspect JudgeAspect{
	public JudgeAspect(){}
	pointcut performance() : execution (* perform(..)); 
	after() returning() : performance(){
		System.out.println(criticismEngine.getCritism());
	}

	//injected
	private CriticismEngine criticismEngine;
	public void setCriticismEngine(CriticismEngine criticismEngine){
		this.criticismEngine = criticismEngine; 
	} 
}

JudgeAspect的主要职责是在表演之后为表演发表评论
JudgeAspect与一个CritismEngine对象协作，在表演结束时候，调用该对象的getCriticism()方法来发表一个评论
为了避免JudgeAspect和CritismEngine之间产生不必要的耦合，通过setter依赖注入为JudgeAspect赋予CriticismEngine

如下关系： 
			通知                 getCritism()
Performer  <------  JudgeAspect --------------> CritismEngine
						   ^					     ^
							\						 |					
							 \	注入进去				 |
							  \						 |
							   \				     |
								\ 			         |

								  CriticismEngineImple


切面也需要注入，如果AspectJ切面需要其他Bean, Spring也可以为AspectJ切面注入依赖

AspectJ切面不需要Spring就可以织入我们的应用中，但是如果想使用Spring的依赖注入为AspectJ切面注入协作者，那么就需要在Spring
配置中把切面声明为一个SpringBean. 如下的<bean> 声明会把criticismEngine bean注入到JudgeAspect中

<bean class = "com.sprininaction.springidol.JudgeAspect" factory-method = "aspectOf"
		<property name="criticismEngine" ref ="criticismEngine" /> 
</bean> 

通常情况下Spring Bean由Spring容器初始化, 但是AspectJ切面是由AspectJ在运行期创建的。等到Spring有机会为JudgeAspect注入
CriticismEngine时，JudgeAspect已经被实例化了。我们需要一种方式为Spring获得已经由AspectJ创建的JudgeAspect实例的句柄,从
而可以注入CriticismEngine. AspectJ提供了一个静态的aspectOf()方法, 该方法返回切面的一个单例. 

JudgeAspect装配CriticismEngineImpl，使用Spring注入为AspectJ切面注入协作者，那么就需要在Spring配置中把切面声明为一个Spring Bean
如下的<bean>声明会把criticismEngine Bean注入到Judge Aspect中

<bean class = "com.springinaction.springidol.JudgeAspect" factory-method= "aspectOf"
	<property name= " criticismEngine" ref = "criticismEngine" /> 
</bean>

简而言之，Spring不能使用<bean>声明来创建一个JudgeAspect实例-它已经在运行时候由AspectJ创建了。Spring通过aspectOf()工厂方法获得切面
的引用, 然后像<bean> 元素规定的那样在该对象上执行依赖注入

II Spring应用程序的核心组件

5.1 Spring的数据访问哲学

服务对象  ------> DAO接口 
				    ^
				    |
				    |
				    |
				    |
				 DAO实现

服务对象本身并不会处理数据访问, 而是将数据访问委托给DAO, DAO接口确保其与服务对象的松耦合。

好处  1.服务对象易于测试, 因为它们不再于特定的数据访问实现绑定在一起。
	  2.数据访问是以持久化技术无关的方式来进行访问的，持久化的选择独立于DAO, 只有相关的数据访问方法通过接口来进行发布.

了解Spring数据访问异常体系
Spring异常体系优于JDBC，几乎为读取和写入数据库所有错误都提供了异常，并不与特定的持久化方式相关联，意味着我们可以使用Spring
抛出一致的异常，而不用关系所选用的持久化方案。这有助于我们将所选择的持久化机制与数据访问层隔离开来。

JBDC异常                                                          Spring的数据访问异常

BatchUpdateException											CannotAcquireLockException
DataTruncation													CannotSerializeTransactionException
SQLException													CleanupFailureException
SQLWarning														ConcurrencyFailureException
																DataAccessException	
																DataAccessResourceFailureException
																DataIntegrityViolationException
																DataRetrieveFailureException
																DeadlockLoserDataAccessException
																EmptyResultDataAccessException
																IncorrectResultSizeDataAccessException
																IncorrectUpdateSemanticsDataAccessException
																InvalidDataAccessApiUsageException
																InvalidDataAccessResourceUsageException
																OptimisticLockingFailureException
																PermissionDeniedDataAccessException
																PessimisticLockingFailureException
																TypeMismatchDataAccessException
																UncategorizedDataAccessException

5.1.2 数据访问模板化

Spring将数据访问过程中固定的和可变的部分划分为:模板template和回调callback
Spring的模板类处理数据访问的固定部分-事务控制，管理资源及处理异常。应用程序相关的数据访问，在回调的实现中处理。

Spring的DAO模板类负责通用的数据访问功能，对于应用程序特定的任务，则会回调自定义的DAO回调对象

Spring的DAO模板负责通用的数据访问功能。对于应用程序的特定任务，则会调用自定义的DAO回调对象

1.准备资源 2.开始事务 3.在事务中执行 4. 返回数据 5提交/回滚事务 6.关闭资源和处理错误

针对不同的持久化平台, Spring提供了多个可选的模板。如果直接使用JDBC, 则可选择JDBC template, 如果希望使用对象关系映射框架
则用hibernate-template或JpaTemplate

模板类(org.springframework.*)                                   用途
jca.cci.core.CciTemplate                                       JCA CCI连接
jdbc.core.JdbcTemplate                                         JDBC连接
jdbc.core.namedparam.NamedParameterJdbcTemplate 			   命名参数的JDBC连接
jdbc.core.simple.SimpleJdbcTemplate							   Java5简化后的JDBC连接
orm.hibernate.HibernateTemplate								   Hibernate2.x的Session
orm.hibernate3.HibernateTemplate							   Hibernate3.x的Session
orm.ibatis.SqlMapClientTemplate								   iBATIS SqlMap客户端
orm.jdo.JdoTemplate											   Java数据对象(Java Data Object)的实现
orm.jpa.Template  											   Java持久化API的实体管理器


5.1.3 使用DAO支持类
基于模板-回调设计，Spring提供了DAO支持类，而将业务自己的DAO类作为它的子类

应用程序DAO -> DAO支持类 -> 数据访问模板 -> 持久化框架 -> 数据库

SpringDAO支持类提供了便携的方式来使用数据访问模板

DAO支持类 														为谁提供DAO支持
jca.cci.support.CciDaoSupport 								 	JCA CCI连接
jdbc.core.support.JdbcDaoSupport								JDBC 连接
jdbc.core.namedparam.NamedParameterJdbcDaoSupport				命名参数的JDBC连接
jdbc.core.simple.SimpleJdbcDaoSupport							Java5简化后的JDBC连接
orm.hibernate.support.HibernateDaoSupport						Hibernate2.x的Session
orm.hibernate3.support.HibernateDaoSupport						Hibernate3.x的Session
orm.ibatis.support.SqlMapClientDaoSupport						iBATIS SqlMap客户端
orm.jdo.support.JdoDaoSupport									Java数据对象(Java Data Object)的实现
orm.jpa.support.JpaDaoSupport									Java持久化API的实体管理器

5.2 配置数据源
不管选择哪一种Spring Dao的支持方式, 你可能都需要配置一个数据源的引用. Spring提供了在Spring上下文中配置数据源Bean
的多种方式, 包括： 
1. 通过JDBC驱动程序定义的数据源
2. 通过JNDI查找的数据源
3. 连接池的数据源

5.2.1使用JNDI数据源

Spring应用程序经常部署在Java EE应用服务器中, 如WebSphere, JBoss或者像Tomcat这样Web容器
利用Spring，我们可以像使用Spring Bean那样配置JNDI中数据源的引用并将其装配到需要的类中.
<jee:jndi-lookup id="dataSource" 
	jndi-name="/jdbc/SpitterDS"
	resources-ref="true" />

jndi-name用于指定JNDI资源中的名称，如果只设置了jndi-name属性，那么就会根据指定的名称查找数据源，
如果应用程序运行在java程序服务器中，则需要将resource-ref属性设置为true

5.2.2 使用数据源连接池

如果你不能从JNDI中查找数据源, 那么下一个选择就是直接在Spring中配置数据源连接池. DBCP包含了多个提供连接池功能的数据源
,其中BasicDataSource	是最常用的


BasicDataSource的池配置属性								所指定的内容	  					
initalSize												池启动时创建的连接数量
maxActive												同一时间可从池中分配的最多连接数，如果设置为0，表示无限制
maxIdle													池里不会被释放的最多空间连接数，如果设置为0，表示无限制 
maxOpenPreparedStatements								在同一时间能够从语句池中分配的预处理语句最大数量，如果设置为0，表示无限制 			
maxWait													在抛出异常前，池等待连接回收的最大时间,设置-1表示无限等待						
minEvictableTimeMillis									连接池中保持空闲而不被收回的最大时间			
minIdle													在不创建新连接的情况下，池中保持空闲的最小连接数 
poolPreparedStatements									是否对预处理语句进行池管理(boolean)

JDBC驱动的数据源

通过JDBC定义驱动是最简单的方式, Spring提供了两种数据源对象供选择
DriverManagerDataSource: 在每个连接请求时，都会返回一个新建的连接，不进行池化管理
SingleConnectionDataSource: 在每个连接请求时都会返回同一个连接。尽管SingleConnectionDataSource不是严格 意义上的连接池数据源,
但是可以视为只有一个连接的池

SingleConnectionDataSource不适用于多线程的应用程序，DriverManagerDataSource支持多线程，但是在每次请求连接时候都会创建新连接
以性能为代价，所以强烈建议使用数据源连接池

5.4在Spring中集成Hibernate

延迟加载(Lazy load)
借助延迟加载，我们可以只抓取需要的数据

预先抓取(Eager fetching)
借助预先抓取，我们可以使用一个查询获取完整的关联对象，预先抓取的功能可以在一个操作中将他们全部从数据库中提取出来，节省了多次查询的成本

级联(Cascading)
有时，更改数据库同时会修改其他表，我们希望一次操作能将关联的表多表修改

ORM(object-relational mapping)
Spring对ORM框架的支持提供了这些框架的集成点以及一些附加的服务
*Spring声明式事务的集成支持
*透明的异常处理
*线程安全，轻量级模板类 
*DAO支持类
*资源管理

5.4.1 Hibernate概览

在Spring应用程序中使用Hibernate是通过HibernateTemplate进行的，HibernateTemplate简化了使用Hibernate的繁琐工作，
并且是通过捕获Hibernate特定的异常，然后转换成Spring的非检查型数据库访问异常并重新抛出而实现的

HibernateTemplate职责之一是管理Hibernate的Session，这涉及打开和关闭Session并确保每个事务使用相同的Session，如果
没有HibernateTemplate, 我们只能让自己的DAO充满了Session管理的样板代码

HibernateTemplate的不足之处在于存在一定程度的入侵性. 当我们在DAO中使用HibernateTemplate时，DAO类就会与Spring API
产生耦合

Hibernate3引入上下文Session(Contextual Session)，这是Hibernate本身所提供的保证每个事务使用同一Session的方案，因此
没有必要使用HibernateTemplate保证这一行为了。在使用Hibernate Contextual Session之前，我们需要为Hibernate做一些准备
工作即在Spring里配置Session Factory

5.4.2 声明Hibernate的Session工厂

使用Hibernate的主要接口时org.hibernate.Session. Session接口提供了基本数据访问功能，CRUD以及从数据库加载对象功能.
标准方式是借助于Hibernate的SessionFactory接口实现类。除了一些其他的任务，SessionFactory主要负责Hibernate Session
的打开，关闭以及管理.

在Spring中，我们要通过Spring的某一个Hibernate Session工厂Bean来获取Hibernate的SessionFactory.我们可以在应用程序
的Spring上下文中，像配置其他Bean那样来配置Hibernate Session工厂

在配置Hibernate Session工厂Bean的时候，我们需要确定持久化域名对象是通过XML文件还是通过注解来进行配置的, 如果你更倾向
用注解的方式来定义持久化，那需要使用AnnotationSessionFactoryBean来替代LocalSessionFactoryBean

dataSource声明从哪里获得数据库连接
hibernateProperties声明了要使用哪一种数据库
packagesToScan属性告诉Spring扫描一个或多个包以查找域类，这些类通过注解方式表明要使用Hibernate进行持久化。
JPA的@Entity 或者



				
